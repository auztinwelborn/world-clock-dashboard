import {
  __commonJS
} from "./chunk-ROME4SDB.js";

// node_modules/@statsig/client-core/src/Log.js
var require_Log = __commonJS({
  "node_modules/@statsig/client-core/src/Log.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Log = exports.LogLevel = void 0;
    var DEBUG = " DEBUG ";
    var _INFO = "  INFO ";
    var _WARN = "  WARN ";
    var ERROR = " ERROR ";
    function addTag(args) {
      args.unshift("[Statsig]");
      return args;
    }
    exports.LogLevel = {
      None: 0,
      Error: 1,
      Warn: 2,
      Info: 3,
      Debug: 4
    };
    var Log = class _Log {
      static info(...args) {
        if (_Log.level >= exports.LogLevel.Info) {
          console.info(_INFO, ...addTag(args));
        }
      }
      static debug(...args) {
        if (_Log.level >= exports.LogLevel.Debug) {
          console.debug(DEBUG, ...addTag(args));
        }
      }
      static warn(...args) {
        if (_Log.level >= exports.LogLevel.Warn) {
          console.warn(_WARN, ...addTag(args));
        }
      }
      static error(...args) {
        if (_Log.level >= exports.LogLevel.Error) {
          console.error(ERROR, ...addTag(args));
        }
      }
    };
    exports.Log = Log;
    Log.level = exports.LogLevel.Warn;
  }
});

// node_modules/@statsig/client-core/src/$_StatsigGlobal.js
var require_StatsigGlobal = __commonJS({
  "node_modules/@statsig/client-core/src/$_StatsigGlobal.js"(exports) {
    "use strict";
    var _a;
    var _b;
    var _c;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._getInstance = exports._getStatsigGlobalFlag = exports._getStatsigGlobal = void 0;
    var Log_1 = require_Log();
    var _getStatsigGlobal = () => {
      try {
        return typeof __STATSIG__ !== "undefined" ? __STATSIG__ : statsigGlobal;
      } catch (e) {
        return statsigGlobal;
      }
    };
    exports._getStatsigGlobal = _getStatsigGlobal;
    var _getStatsigGlobalFlag = (flag) => {
      return (0, exports._getStatsigGlobal)()[flag];
    };
    exports._getStatsigGlobalFlag = _getStatsigGlobalFlag;
    var _getInstance = (sdkKey) => {
      const gbl = (0, exports._getStatsigGlobal)();
      if (!sdkKey) {
        if (gbl.instances && Object.keys(gbl.instances).length > 1) {
          Log_1.Log.warn("Call made to Statsig global instance without an SDK key but there is more than one client instance. If you are using mulitple clients, please specify the SDK key.");
        }
        return gbl.firstInstance;
      }
      return gbl.instances && gbl.instances[sdkKey];
    };
    exports._getInstance = _getInstance;
    var GLOBAL_KEY = "__STATSIG__";
    var _window = typeof window !== "undefined" ? window : {};
    var _global = typeof global !== "undefined" ? global : {};
    var _globalThis = typeof globalThis !== "undefined" ? globalThis : {};
    var statsigGlobal = (_c = (_b = (_a = _window[GLOBAL_KEY]) !== null && _a !== void 0 ? _a : _global[GLOBAL_KEY]) !== null && _b !== void 0 ? _b : _globalThis[GLOBAL_KEY]) !== null && _c !== void 0 ? _c : {
      instance: exports._getInstance
    };
    _window[GLOBAL_KEY] = statsigGlobal;
    _global[GLOBAL_KEY] = statsigGlobal;
    _globalThis[GLOBAL_KEY] = statsigGlobal;
  }
});

// node_modules/@statsig/client-core/src/Diagnostics.js
var require_Diagnostics = __commonJS({
  "node_modules/@statsig/client-core/src/Diagnostics.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Diagnostics = void 0;
    var MARKER_MAP = /* @__PURE__ */ new Map();
    var ACT_START = "start";
    var ACT_END = "end";
    var DIAGNOSTICS_EVENT = "statsig::diagnostics";
    exports.Diagnostics = {
      _getMarkers: (sdkKey) => {
        return MARKER_MAP.get(sdkKey);
      },
      _markInitOverallStart: (sdkKey) => {
        _addMarker(sdkKey, _createMarker({}, ACT_START, "overall"));
      },
      _markInitOverallEnd: (sdkKey, success, evaluationDetails) => {
        _addMarker(sdkKey, _createMarker({
          success,
          error: success ? void 0 : { name: "InitializeError", message: "Failed to initialize" },
          evaluationDetails
        }, ACT_END, "overall"));
      },
      _markInitNetworkReqStart: (sdkKey, data) => {
        _addMarker(sdkKey, _createMarker(data, ACT_START, "initialize", "network_request"));
      },
      _markInitNetworkReqEnd: (sdkKey, data) => {
        _addMarker(sdkKey, _createMarker(data, ACT_END, "initialize", "network_request"));
      },
      _markInitProcessStart: (sdkKey) => {
        _addMarker(sdkKey, _createMarker({}, ACT_START, "initialize", "process"));
      },
      _markInitProcessEnd: (sdkKey, data) => {
        _addMarker(sdkKey, _createMarker(data, ACT_END, "initialize", "process"));
      },
      _clearMarkers: (sdkKey) => {
        MARKER_MAP.delete(sdkKey);
      },
      _formatError(e) {
        if (!(e && typeof e === "object")) {
          return;
        }
        return {
          code: _safeGetField(e, "code"),
          name: _safeGetField(e, "name"),
          message: _safeGetField(e, "message")
        };
      },
      _getDiagnosticsData(res, attempt, body, e) {
        var _a;
        return {
          success: (res === null || res === void 0 ? void 0 : res.ok) === true,
          statusCode: res === null || res === void 0 ? void 0 : res.status,
          sdkRegion: (_a = res === null || res === void 0 ? void 0 : res.headers) === null || _a === void 0 ? void 0 : _a.get("x-statsig-region"),
          isDelta: body.includes('"is_delta":true') === true ? true : void 0,
          attempt,
          error: exports.Diagnostics._formatError(e)
        };
      },
      _enqueueDiagnosticsEvent(user, logger, sdk, options) {
        const markers = exports.Diagnostics._getMarkers(sdk);
        if (markers == null || markers.length <= 0) {
          return -1;
        }
        const overallInitDuration = markers[markers.length - 1].timestamp - markers[0].timestamp;
        exports.Diagnostics._clearMarkers(sdk);
        const event = _makeDiagnosticsEvent(user, {
          context: "initialize",
          markers: markers.slice(),
          statsigOptions: options
        });
        logger.enqueue(event);
        return overallInitDuration;
      }
    };
    function _createMarker(data, action, key, step) {
      return Object.assign({ key, action, step, timestamp: Date.now() }, data);
    }
    function _makeDiagnosticsEvent(user, data) {
      const latencyEvent = {
        eventName: DIAGNOSTICS_EVENT,
        user,
        value: null,
        metadata: data,
        time: Date.now()
      };
      return latencyEvent;
    }
    function _addMarker(sdkKey, marker) {
      var _a;
      const markers = (_a = MARKER_MAP.get(sdkKey)) !== null && _a !== void 0 ? _a : [];
      markers.push(marker);
      MARKER_MAP.set(sdkKey, markers);
    }
    function _safeGetField(data, field) {
      if (field in data) {
        return data[field];
      }
      return void 0;
    }
  }
});

// node_modules/@statsig/client-core/src/TypingUtils.js
var require_TypingUtils = __commonJS({
  "node_modules/@statsig/client-core/src/TypingUtils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._isTypeMatch = exports._typeOf = void 0;
    function _typeOf(input) {
      return Array.isArray(input) ? "array" : typeof input;
    }
    exports._typeOf = _typeOf;
    function _isTypeMatch(a, b) {
      const typeOf = (x) => Array.isArray(x) ? "array" : typeof x;
      return typeOf(a) === typeOf(b);
    }
    exports._isTypeMatch = _isTypeMatch;
  }
});

// node_modules/@statsig/client-core/src/Hashing.js
var require_Hashing = __commonJS({
  "node_modules/@statsig/client-core/src/Hashing.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._getSortedObject = exports._DJB2Object = exports._DJB2 = void 0;
    var TypingUtils_1 = require_TypingUtils();
    var _DJB2 = (value) => {
      let hash = 0;
      for (let i = 0; i < value.length; i++) {
        const character = value.charCodeAt(i);
        hash = (hash << 5) - hash + character;
        hash = hash & hash;
      }
      return String(hash >>> 0);
    };
    exports._DJB2 = _DJB2;
    var _DJB2Object = (value, maxLevels) => {
      return (0, exports._DJB2)(JSON.stringify((0, exports._getSortedObject)(value, maxLevels)));
    };
    exports._DJB2Object = _DJB2Object;
    var _getSortedObject = (object, maxDepth) => {
      if (object == null) {
        return null;
      }
      const keys = Object.keys(object).sort();
      const sortedObject = {};
      keys.forEach((key) => {
        const value = object[key];
        if (maxDepth === 0 || (0, TypingUtils_1._typeOf)(value) !== "object") {
          sortedObject[key] = value;
          return;
        }
        sortedObject[key] = (0, exports._getSortedObject)(value, maxDepth != null ? maxDepth - 1 : maxDepth);
      });
      return sortedObject;
    };
    exports._getSortedObject = _getSortedObject;
  }
});

// node_modules/@statsig/client-core/src/CacheKey.js
var require_CacheKey = __commonJS({
  "node_modules/@statsig/client-core/src/CacheKey.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._getStorageKey = exports._getUserStorageKey = void 0;
    var Hashing_1 = require_Hashing();
    function _getUserStorageKey(sdkKey, user, customKeyGenerator) {
      var _a;
      if (customKeyGenerator) {
        return customKeyGenerator(sdkKey, user);
      }
      const cids = user && user.customIDs ? user.customIDs : {};
      const parts = [
        `uid:${(_a = user === null || user === void 0 ? void 0 : user.userID) !== null && _a !== void 0 ? _a : ""}`,
        `cids:${Object.keys(cids).sort((leftKey, rightKey) => leftKey.localeCompare(rightKey)).map((key) => `${key}-${cids[key]}`).join(",")}`,
        `k:${sdkKey}`
      ];
      return (0, Hashing_1._DJB2)(parts.join("|"));
    }
    exports._getUserStorageKey = _getUserStorageKey;
    function _getStorageKey(sdkKey, user, customKeyGenerator) {
      if (user) {
        return _getUserStorageKey(sdkKey, user, customKeyGenerator);
      }
      return (0, Hashing_1._DJB2)(`k:${sdkKey}`);
    }
    exports._getStorageKey = _getStorageKey;
  }
});

// node_modules/@statsig/client-core/src/NetworkConfig.js
var require_NetworkConfig = __commonJS({
  "node_modules/@statsig/client-core/src/NetworkConfig.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NetworkParam = exports.NetworkDefault = exports.Endpoint = void 0;
    exports.Endpoint = {
      _initialize: "initialize",
      _rgstr: "rgstr",
      _download_config_specs: "download_config_specs"
    };
    exports.NetworkDefault = {
      [exports.Endpoint._rgstr]: "https://prodregistryv2.org/v1",
      [exports.Endpoint._initialize]: "https://featureassets.org/v1",
      [exports.Endpoint._download_config_specs]: "https://api.statsigcdn.com/v1"
    };
    exports.NetworkParam = {
      EventCount: "ec",
      SdkKey: "k",
      SdkType: "st",
      SdkVersion: "sv",
      Time: "t",
      SessionID: "sid",
      StatsigEncoded: "se",
      IsGzipped: "gz"
    };
  }
});

// node_modules/@statsig/client-core/src/SafeJs.js
var require_SafeJs = __commonJS({
  "node_modules/@statsig/client-core/src/SafeJs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._getUnloadEvent = exports._getCurrentPageUrlSafe = exports._addDocumentEventListenerSafe = exports._addWindowEventListenerSafe = exports._isServerEnv = exports._getDocumentSafe = exports._getWindowSafe = void 0;
    var _getWindowSafe = () => {
      return typeof window !== "undefined" ? window : null;
    };
    exports._getWindowSafe = _getWindowSafe;
    var _getDocumentSafe = () => {
      var _a;
      const win = (0, exports._getWindowSafe)();
      return (_a = win === null || win === void 0 ? void 0 : win.document) !== null && _a !== void 0 ? _a : null;
    };
    exports._getDocumentSafe = _getDocumentSafe;
    var _isServerEnv = () => {
      if ((0, exports._getDocumentSafe)() !== null) {
        return false;
      }
      const isNode = typeof process !== "undefined" && process.versions != null && process.versions.node != null;
      const isVercel = typeof EdgeRuntime === "string";
      return isVercel || isNode;
    };
    exports._isServerEnv = _isServerEnv;
    var _addWindowEventListenerSafe = (key, listener) => {
      const win = (0, exports._getWindowSafe)();
      if (typeof (win === null || win === void 0 ? void 0 : win.addEventListener) === "function") {
        win.addEventListener(key, listener);
      }
    };
    exports._addWindowEventListenerSafe = _addWindowEventListenerSafe;
    var _addDocumentEventListenerSafe = (key, listener) => {
      const doc = (0, exports._getDocumentSafe)();
      if (typeof (doc === null || doc === void 0 ? void 0 : doc.addEventListener) === "function") {
        doc.addEventListener(key, listener);
      }
    };
    exports._addDocumentEventListenerSafe = _addDocumentEventListenerSafe;
    var _getCurrentPageUrlSafe = () => {
      var _a;
      try {
        return (_a = (0, exports._getWindowSafe)()) === null || _a === void 0 ? void 0 : _a.location.href.split(/[?#]/)[0];
      } catch (_b) {
        return;
      }
    };
    exports._getCurrentPageUrlSafe = _getCurrentPageUrlSafe;
    var _getUnloadEvent = () => {
      const win = (0, exports._getWindowSafe)();
      if (!win) {
        return "beforeunload";
      }
      const eventType = "onpagehide" in win ? "pagehide" : "beforeunload";
      return eventType;
    };
    exports._getUnloadEvent = _getUnloadEvent;
  }
});

// node_modules/@statsig/client-core/src/StatsigEvent.js
var require_StatsigEvent = __commonJS({
  "node_modules/@statsig/client-core/src/StatsigEvent.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._createLayerParameterExposure = exports._createConfigExposure = exports._mapExposures = exports._createGateExposure = exports._isExposureEvent = void 0;
    var CONFIG_EXPOSURE_NAME = "statsig::config_exposure";
    var GATE_EXPOSURE_NAME = "statsig::gate_exposure";
    var LAYER_EXPOSURE_NAME = "statsig::layer_exposure";
    var _createExposure = (eventName, user, details, metadata, secondaryExposures) => {
      if (details.bootstrapMetadata) {
        metadata["bootstrapMetadata"] = details.bootstrapMetadata;
      }
      return {
        eventName,
        user,
        value: null,
        metadata: _addEvaluationDetailsToMetadata(details, metadata),
        secondaryExposures,
        time: Date.now()
      };
    };
    var _isExposureEvent = ({ eventName }) => {
      return eventName === GATE_EXPOSURE_NAME || eventName === CONFIG_EXPOSURE_NAME || eventName === LAYER_EXPOSURE_NAME;
    };
    exports._isExposureEvent = _isExposureEvent;
    var _createGateExposure = (user, gate, exposureMapping) => {
      var _a, _b, _c;
      const metadata = {
        gate: gate.name,
        gateValue: String(gate.value),
        ruleID: gate.ruleID
      };
      if (((_a = gate.__evaluation) === null || _a === void 0 ? void 0 : _a.version) != null) {
        metadata["configVersion"] = gate.__evaluation.version;
      }
      return _createExposure(GATE_EXPOSURE_NAME, user, gate.details, metadata, _mapExposures((_c = (_b = gate.__evaluation) === null || _b === void 0 ? void 0 : _b.secondary_exposures) !== null && _c !== void 0 ? _c : [], exposureMapping));
    };
    exports._createGateExposure = _createGateExposure;
    function _mapExposures(exposures, exposureMapping) {
      return exposures.map((exposure) => {
        if (typeof exposure === "string") {
          return (exposureMapping !== null && exposureMapping !== void 0 ? exposureMapping : {})[exposure];
        }
        return exposure;
      }).filter((exposure) => exposure != null);
    }
    exports._mapExposures = _mapExposures;
    var _createConfigExposure = (user, config, exposureMapping) => {
      var _a, _b, _c, _d;
      const metadata = {
        config: config.name,
        ruleID: config.ruleID
      };
      if (((_a = config.__evaluation) === null || _a === void 0 ? void 0 : _a.version) != null) {
        metadata["configVersion"] = config.__evaluation.version;
      }
      if (((_b = config.__evaluation) === null || _b === void 0 ? void 0 : _b.passed) != null) {
        metadata["rulePassed"] = String(config.__evaluation.passed);
      }
      return _createExposure(CONFIG_EXPOSURE_NAME, user, config.details, metadata, _mapExposures((_d = (_c = config.__evaluation) === null || _c === void 0 ? void 0 : _c.secondary_exposures) !== null && _d !== void 0 ? _d : [], exposureMapping));
    };
    exports._createConfigExposure = _createConfigExposure;
    var _createLayerParameterExposure = (user, layer, parameterName, exposureMapping) => {
      var _a, _b, _c, _d, _e, _f;
      const evaluation = layer.__evaluation;
      const isExplicit = ((_a = evaluation === null || evaluation === void 0 ? void 0 : evaluation.explicit_parameters) === null || _a === void 0 ? void 0 : _a.includes(parameterName)) === true;
      let allocatedExperiment = "";
      let secondaryExposures = (_b = evaluation === null || evaluation === void 0 ? void 0 : evaluation.undelegated_secondary_exposures) !== null && _b !== void 0 ? _b : [];
      if (isExplicit) {
        allocatedExperiment = (_c = evaluation.allocated_experiment_name) !== null && _c !== void 0 ? _c : "";
        secondaryExposures = evaluation.secondary_exposures;
      }
      const parameterRuleIDs = (_d = layer.__evaluation) === null || _d === void 0 ? void 0 : _d.parameter_rule_ids;
      const metadata = {
        config: layer.name,
        parameterName,
        ruleID: (_e = parameterRuleIDs === null || parameterRuleIDs === void 0 ? void 0 : parameterRuleIDs[parameterName]) !== null && _e !== void 0 ? _e : layer.ruleID,
        allocatedExperiment,
        isExplicitParameter: String(isExplicit)
      };
      if (((_f = layer.__evaluation) === null || _f === void 0 ? void 0 : _f.version) != null) {
        metadata["configVersion"] = layer.__evaluation.version;
      }
      return _createExposure(LAYER_EXPOSURE_NAME, user, layer.details, metadata, _mapExposures(secondaryExposures, exposureMapping));
    };
    exports._createLayerParameterExposure = _createLayerParameterExposure;
    var _addEvaluationDetailsToMetadata = (details, metadata) => {
      metadata["reason"] = details.reason;
      if (details.lcut) {
        metadata["lcut"] = String(details.lcut);
      }
      if (details.receivedAt) {
        metadata["receivedAt"] = String(details.receivedAt);
      }
      return metadata;
    };
  }
});

// node_modules/@statsig/client-core/src/StatsigOptionsCommon.js
var require_StatsigOptionsCommon = __commonJS({
  "node_modules/@statsig/client-core/src/StatsigOptionsCommon.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LoggingEnabledOption = exports.LogEventCompressionMode = void 0;
    exports.LogEventCompressionMode = {
      /** Do not compress request bodies */
      Disabled: "d",
      /** Compress request bodies unless a network proxy is configured */
      Enabled: "e",
      /** Always compress request bodies, even when a proxy is configured */
      Forced: "f"
    };
    exports.LoggingEnabledOption = {
      disabled: "disabled",
      browserOnly: "browser-only",
      always: "always"
    };
  }
});

// node_modules/@statsig/client-core/src/StorageProvider.js
var require_StorageProvider = __commonJS({
  "node_modules/@statsig/client-core/src/StorageProvider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._setObjectInStorage = exports._getObjectFromStorage = exports.Storage = void 0;
    var Log_1 = require_Log();
    var SafeJs_1 = require_SafeJs();
    var inMemoryStore = {};
    var _inMemoryProvider = {
      isReady: () => true,
      isReadyResolver: () => null,
      getProviderName: () => "InMemory",
      getItem: (key) => inMemoryStore[key] ? inMemoryStore[key] : null,
      setItem: (key, value) => {
        inMemoryStore[key] = value;
      },
      removeItem: (key) => {
        delete inMemoryStore[key];
      },
      getAllKeys: () => Object.keys(inMemoryStore)
    };
    var _localStorageProvider = null;
    try {
      const win = (0, SafeJs_1._getWindowSafe)();
      if (win && win.localStorage && typeof win.localStorage.getItem === "function") {
        _localStorageProvider = {
          isReady: () => true,
          isReadyResolver: () => null,
          getProviderName: () => "LocalStorage",
          getItem: (key) => win.localStorage.getItem(key),
          setItem: (key, value) => win.localStorage.setItem(key, value),
          removeItem: (key) => win.localStorage.removeItem(key),
          getAllKeys: () => Object.keys(win.localStorage)
        };
      }
    } catch (error) {
      Log_1.Log.warn("Failed to setup localStorageProvider.");
    }
    var _main = _localStorageProvider !== null && _localStorageProvider !== void 0 ? _localStorageProvider : _inMemoryProvider;
    var _current = _main;
    function _inMemoryBreaker(action) {
      try {
        return action();
      } catch (error) {
        if (error instanceof Error && error.name === "SecurityError") {
          exports.Storage._setProvider(_inMemoryProvider);
          return null;
        }
        if (error instanceof Error && error.name === "QuotaExceededError") {
          const allKeys = exports.Storage.getAllKeys();
          const statsigKeys = allKeys.filter((key) => key.startsWith("statsig."));
          error.message = `${error.message}. Statsig Keys: ${statsigKeys.length}`;
        }
        throw error;
      }
    }
    exports.Storage = {
      isReady: () => _current.isReady(),
      isReadyResolver: () => _current.isReadyResolver(),
      getProviderName: () => _current.getProviderName(),
      getItem: (key) => _inMemoryBreaker(() => _current.getItem(key)),
      setItem: (key, value) => _inMemoryBreaker(() => _current.setItem(key, value)),
      removeItem: (key) => _current.removeItem(key),
      getAllKeys: () => _current.getAllKeys(),
      // StorageProviderManagment
      _setProvider: (newProvider) => {
        _main = newProvider;
        _current = newProvider;
      },
      _setDisabled: (isDisabled) => {
        if (isDisabled) {
          _current = _inMemoryProvider;
        } else {
          _current = _main;
        }
      }
    };
    function _getObjectFromStorage(key) {
      const value = exports.Storage.getItem(key);
      return JSON.parse(value !== null && value !== void 0 ? value : "null");
    }
    exports._getObjectFromStorage = _getObjectFromStorage;
    function _setObjectInStorage(key, obj) {
      exports.Storage.setItem(key, JSON.stringify(obj));
    }
    exports._setObjectInStorage = _setObjectInStorage;
  }
});

// node_modules/@statsig/client-core/src/UrlConfiguration.js
var require_UrlConfiguration = __commonJS({
  "node_modules/@statsig/client-core/src/UrlConfiguration.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UrlConfiguration = void 0;
    var Hashing_1 = require_Hashing();
    var NetworkConfig_1 = require_NetworkConfig();
    var ENDPOINT_DNS_KEY_MAP = {
      [NetworkConfig_1.Endpoint._initialize]: "i",
      [NetworkConfig_1.Endpoint._rgstr]: "e",
      [NetworkConfig_1.Endpoint._download_config_specs]: "d"
    };
    var UrlConfiguration = class {
      constructor(endpoint, customUrl, customApi, fallbackUrls) {
        this.customUrl = null;
        this.fallbackUrls = null;
        this.endpoint = endpoint;
        this.endpointDnsKey = ENDPOINT_DNS_KEY_MAP[endpoint];
        if (customUrl) {
          this.customUrl = customUrl;
        }
        if (!customUrl && customApi) {
          this.customUrl = customApi.endsWith("/") ? `${customApi}${endpoint}` : `${customApi}/${endpoint}`;
        }
        if (fallbackUrls) {
          this.fallbackUrls = fallbackUrls;
        }
        const defaultApi = NetworkConfig_1.NetworkDefault[endpoint];
        this.defaultUrl = `${defaultApi}/${endpoint}`;
      }
      getUrl() {
        var _a;
        return (_a = this.customUrl) !== null && _a !== void 0 ? _a : this.defaultUrl;
      }
      getChecksum() {
        var _a;
        const fallbacks = ((_a = this.fallbackUrls) !== null && _a !== void 0 ? _a : []).sort().join(",");
        return (0, Hashing_1._DJB2)(this.customUrl + fallbacks);
      }
    };
    exports.UrlConfiguration = UrlConfiguration;
  }
});

// node_modules/@statsig/client-core/src/VisibilityObserving.js
var require_VisibilityObserving = __commonJS({
  "node_modules/@statsig/client-core/src/VisibilityObserving.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._notifyVisibilityChanged = exports._subscribeToVisiblityChanged = exports._isUnloading = exports._isCurrentlyVisible = void 0;
    var SafeJs_1 = require_SafeJs();
    var FOREGROUND = "foreground";
    var BACKGROUND = "background";
    var LISTENERS = [];
    var current = FOREGROUND;
    var isUnloading = false;
    var _isCurrentlyVisible = () => {
      return current === FOREGROUND;
    };
    exports._isCurrentlyVisible = _isCurrentlyVisible;
    var _isUnloading = () => isUnloading;
    exports._isUnloading = _isUnloading;
    var _subscribeToVisiblityChanged = (listener) => {
      LISTENERS.unshift(listener);
    };
    exports._subscribeToVisiblityChanged = _subscribeToVisiblityChanged;
    var _notifyVisibilityChanged = (visibility) => {
      if (visibility === current) {
        return;
      }
      current = visibility;
      LISTENERS.forEach((l) => l(visibility));
    };
    exports._notifyVisibilityChanged = _notifyVisibilityChanged;
    (0, SafeJs_1._addWindowEventListenerSafe)("focus", () => {
      isUnloading = false;
      (0, exports._notifyVisibilityChanged)(FOREGROUND);
    });
    (0, SafeJs_1._addWindowEventListenerSafe)("blur", () => (0, exports._notifyVisibilityChanged)(BACKGROUND));
    (0, SafeJs_1._addDocumentEventListenerSafe)("visibilitychange", () => {
      (0, exports._notifyVisibilityChanged)(document.visibilityState === "visible" ? FOREGROUND : BACKGROUND);
    });
    (0, SafeJs_1._addWindowEventListenerSafe)((0, SafeJs_1._getUnloadEvent)(), () => {
      isUnloading = true;
      (0, exports._notifyVisibilityChanged)(BACKGROUND);
    });
  }
});

// node_modules/@statsig/client-core/src/EventLogger.js
var require_EventLogger = __commonJS({
  "node_modules/@statsig/client-core/src/EventLogger.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EventLogger = void 0;
    var CacheKey_1 = require_CacheKey();
    var Hashing_1 = require_Hashing();
    var Log_1 = require_Log();
    var NetworkConfig_1 = require_NetworkConfig();
    var SafeJs_1 = require_SafeJs();
    var StatsigEvent_1 = require_StatsigEvent();
    var StatsigOptionsCommon_1 = require_StatsigOptionsCommon();
    var StorageProvider_1 = require_StorageProvider();
    var UrlConfiguration_1 = require_UrlConfiguration();
    var VisibilityObserving_1 = require_VisibilityObserving();
    var DEFAULT_QUEUE_SIZE = 100;
    var DEFAULT_FLUSH_INTERVAL_MS = 1e4;
    var MAX_DEDUPER_KEYS = 1e3;
    var DEDUPER_WINDOW_DURATION_MS = 6e5;
    var MAX_FAILED_LOGS = 500;
    var QUICK_FLUSH_WINDOW_MS = 200;
    var EVENT_LOGGER_MAP = {};
    var RetryFailedLogsTrigger = {
      Startup: "startup",
      GainedFocus: "gained_focus"
    };
    var EventLogger = class _EventLogger {
      static _safeFlushAndForget(sdkKey) {
        var _a;
        (_a = EVENT_LOGGER_MAP[sdkKey]) === null || _a === void 0 ? void 0 : _a.flush().catch(() => {
        });
      }
      static _safeRetryFailedLogs(sdkKey) {
        var _a;
        (_a = EVENT_LOGGER_MAP[sdkKey]) === null || _a === void 0 ? void 0 : _a._retryFailedLogs(RetryFailedLogsTrigger.GainedFocus);
      }
      constructor(_sdkKey, _emitter, _network, _options) {
        var _a, _b;
        this._sdkKey = _sdkKey;
        this._emitter = _emitter;
        this._network = _network;
        this._options = _options;
        this._queue = [];
        this._lastExposureTimeMap = {};
        this._nonExposedChecks = {};
        this._hasRunQuickFlush = false;
        this._creationTime = Date.now();
        this._loggingEnabled = (_a = _options === null || _options === void 0 ? void 0 : _options.loggingEnabled) !== null && _a !== void 0 ? _a : (_options === null || _options === void 0 ? void 0 : _options.disableLogging) === true ? StatsigOptionsCommon_1.LoggingEnabledOption.disabled : StatsigOptionsCommon_1.LoggingEnabledOption.browserOnly;
        if ((_options === null || _options === void 0 ? void 0 : _options.loggingEnabled) && _options.disableLogging !== void 0) {
          Log_1.Log.warn("Detected both loggingEnabled and disableLogging options. loggingEnabled takes precedence - please remove disableLogging.");
        }
        this._maxQueueSize = (_b = _options === null || _options === void 0 ? void 0 : _options.loggingBufferMaxSize) !== null && _b !== void 0 ? _b : DEFAULT_QUEUE_SIZE;
        const config = _options === null || _options === void 0 ? void 0 : _options.networkConfig;
        this._logEventUrlConfig = new UrlConfiguration_1.UrlConfiguration(NetworkConfig_1.Endpoint._rgstr, config === null || config === void 0 ? void 0 : config.logEventUrl, config === null || config === void 0 ? void 0 : config.api, config === null || config === void 0 ? void 0 : config.logEventFallbackUrls);
      }
      setLogEventCompressionMode(mode) {
        this._network.setLogEventCompressionMode(mode);
      }
      setLoggingEnabled(loggingEnabled) {
        this._loggingEnabled = loggingEnabled;
      }
      enqueue(event) {
        if (!this._shouldLogEvent(event)) {
          return;
        }
        this._normalizeAndAppendEvent(event);
        this._quickFlushIfNeeded();
        if (this._queue.length > this._maxQueueSize) {
          _EventLogger._safeFlushAndForget(this._sdkKey);
        }
      }
      incrementNonExposureCount(name) {
        var _a;
        const current = (_a = this._nonExposedChecks[name]) !== null && _a !== void 0 ? _a : 0;
        this._nonExposedChecks[name] = current + 1;
      }
      reset() {
        this._lastExposureTimeMap = {};
      }
      start() {
        var _a;
        const isServerEnv = (0, SafeJs_1._isServerEnv)();
        if (isServerEnv && ((_a = this._options) === null || _a === void 0 ? void 0 : _a.loggingEnabled) !== "always") {
          return;
        }
        EVENT_LOGGER_MAP[this._sdkKey] = this;
        if (!isServerEnv) {
          (0, VisibilityObserving_1._subscribeToVisiblityChanged)((visibility) => {
            if (visibility === "background") {
              _EventLogger._safeFlushAndForget(this._sdkKey);
            } else if (visibility === "foreground") {
              _EventLogger._safeRetryFailedLogs(this._sdkKey);
            }
          });
        }
        this._retryFailedLogs(RetryFailedLogsTrigger.Startup);
        this._startBackgroundFlushInterval();
      }
      stop() {
        return __awaiter(this, void 0, void 0, function* () {
          if (this._flushIntervalId) {
            clearInterval(this._flushIntervalId);
            this._flushIntervalId = null;
          }
          delete EVENT_LOGGER_MAP[this._sdkKey];
          yield this.flush();
        });
      }
      flush() {
        return __awaiter(this, void 0, void 0, function* () {
          this._appendAndResetNonExposedChecks();
          if (this._queue.length === 0) {
            return;
          }
          const events = this._queue;
          this._queue = [];
          yield this._sendEvents(events);
        });
      }
      /**
       * We 'Quick Flush' following the very first event enqueued
       * within the quick flush window
       */
      _quickFlushIfNeeded() {
        if (this._hasRunQuickFlush) {
          return;
        }
        this._hasRunQuickFlush = true;
        if (Date.now() - this._creationTime > QUICK_FLUSH_WINDOW_MS) {
          return;
        }
        setTimeout(() => _EventLogger._safeFlushAndForget(this._sdkKey), QUICK_FLUSH_WINDOW_MS);
      }
      _shouldLogEvent(event) {
        var _a;
        if (((_a = this._options) === null || _a === void 0 ? void 0 : _a.loggingEnabled) !== "always" && (0, SafeJs_1._isServerEnv)()) {
          return false;
        }
        if (!(0, StatsigEvent_1._isExposureEvent)(event)) {
          return true;
        }
        const user = event.user ? event.user : { statsigEnvironment: void 0 };
        const userKey = (0, CacheKey_1._getUserStorageKey)(this._sdkKey, user);
        const metadata = event.metadata ? event.metadata : {};
        const key = [
          event.eventName,
          userKey,
          metadata["gate"],
          metadata["config"],
          metadata["ruleID"],
          metadata["allocatedExperiment"],
          metadata["parameterName"],
          String(metadata["isExplicitParameter"]),
          metadata["reason"]
        ].join("|");
        const previous = this._lastExposureTimeMap[key];
        const now = Date.now();
        if (previous && now - previous < DEDUPER_WINDOW_DURATION_MS) {
          return false;
        }
        if (Object.keys(this._lastExposureTimeMap).length > MAX_DEDUPER_KEYS) {
          this._lastExposureTimeMap = {};
        }
        this._lastExposureTimeMap[key] = now;
        return true;
      }
      _sendEvents(events) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
          if (this._loggingEnabled === "disabled") {
            this._saveFailedLogsToStorage(events);
            return false;
          }
          try {
            const isClosing = (0, VisibilityObserving_1._isUnloading)();
            const shouldUseBeacon = isClosing && this._network.isBeaconSupported() && ((_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.networkConfig) === null || _b === void 0 ? void 0 : _b.networkOverrideFunc) == null;
            this._emitter({
              name: "pre_logs_flushed",
              events
            });
            const response = shouldUseBeacon ? this._sendEventsViaBeacon(events) : yield this._sendEventsViaPost(events);
            if (response.success) {
              this._emitter({
                name: "logs_flushed",
                events
              });
              return true;
            } else {
              Log_1.Log.warn("Failed to flush events.");
              this._saveFailedLogsToStorage(events);
              return false;
            }
          } catch (_c) {
            Log_1.Log.warn("Failed to flush events.");
            return false;
          }
        });
      }
      _sendEventsViaPost(events) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          const result = yield this._network.post(this._getRequestData(events));
          const code = (_a = result === null || result === void 0 ? void 0 : result.code) !== null && _a !== void 0 ? _a : -1;
          return { success: code >= 200 && code < 300 };
        });
      }
      _sendEventsViaBeacon(events) {
        return {
          success: this._network.beacon(this._getRequestData(events))
        };
      }
      _getRequestData(events) {
        return {
          sdkKey: this._sdkKey,
          data: {
            events
          },
          urlConfig: this._logEventUrlConfig,
          retries: 3,
          isCompressable: true,
          params: {
            [NetworkConfig_1.NetworkParam.EventCount]: String(events.length)
          },
          credentials: "same-origin"
        };
      }
      _saveFailedLogsToStorage(events) {
        while (events.length > MAX_FAILED_LOGS) {
          events.shift();
        }
        const storageKey = this._getStorageKey();
        try {
          (0, StorageProvider_1._setObjectInStorage)(storageKey, events);
        } catch (_a) {
          Log_1.Log.warn("Unable to save failed logs to storage");
        }
      }
      _retryFailedLogs(trigger) {
        const storageKey = this._getStorageKey();
        (() => __awaiter(this, void 0, void 0, function* () {
          if (!StorageProvider_1.Storage.isReady()) {
            yield StorageProvider_1.Storage.isReadyResolver();
          }
          const events = (0, StorageProvider_1._getObjectFromStorage)(storageKey);
          if (!events) {
            return;
          }
          if (trigger === RetryFailedLogsTrigger.Startup) {
            StorageProvider_1.Storage.removeItem(storageKey);
          }
          const isSuccess = yield this._sendEvents(events);
          if (isSuccess && trigger === RetryFailedLogsTrigger.GainedFocus) {
            StorageProvider_1.Storage.removeItem(storageKey);
          }
        }))().catch(() => {
          Log_1.Log.warn("Failed to flush stored logs");
        });
      }
      _getStorageKey() {
        return `statsig.failed_logs.${(0, Hashing_1._DJB2)(this._sdkKey)}`;
      }
      _normalizeAndAppendEvent(event) {
        if (event.user) {
          event.user = Object.assign({}, event.user);
          delete event.user.privateAttributes;
        }
        const extras = {};
        const currentPage = this._getCurrentPageUrl();
        if (currentPage) {
          extras.statsigMetadata = { currentPage };
        }
        const final = Object.assign(Object.assign({}, event), extras);
        Log_1.Log.debug("Enqueued Event:", final);
        this._queue.push(final);
      }
      _appendAndResetNonExposedChecks() {
        if (Object.keys(this._nonExposedChecks).length === 0) {
          return;
        }
        this._normalizeAndAppendEvent({
          eventName: "statsig::non_exposed_checks",
          user: null,
          time: Date.now(),
          metadata: {
            checks: Object.assign({}, this._nonExposedChecks)
          }
        });
        this._nonExposedChecks = {};
      }
      _getCurrentPageUrl() {
        var _a;
        if (((_a = this._options) === null || _a === void 0 ? void 0 : _a.includeCurrentPageUrlWithEvents) === false) {
          return;
        }
        return (0, SafeJs_1._getCurrentPageUrlSafe)();
      }
      _startBackgroundFlushInterval() {
        var _a, _b;
        const flushInterval = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.loggingIntervalMs) !== null && _b !== void 0 ? _b : DEFAULT_FLUSH_INTERVAL_MS;
        const intervalId = setInterval(() => {
          const logger = EVENT_LOGGER_MAP[this._sdkKey];
          if (!logger || logger._flushIntervalId !== intervalId) {
            clearInterval(intervalId);
          } else {
            _EventLogger._safeFlushAndForget(this._sdkKey);
          }
        }, flushInterval);
        this._flushIntervalId = intervalId;
      }
    };
    exports.EventLogger = EventLogger;
  }
});

// node_modules/@statsig/client-core/src/StatsigMetadata.js
var require_StatsigMetadata = __commonJS({
  "node_modules/@statsig/client-core/src/StatsigMetadata.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StatsigMetadataProvider = exports.SDK_VERSION = void 0;
    exports.SDK_VERSION = "3.18.0";
    var metadata = {
      sdkVersion: exports.SDK_VERSION,
      sdkType: "js-mono"
      // js-mono is overwritten by Precomp and OnDevice clients
    };
    exports.StatsigMetadataProvider = {
      get: () => metadata,
      add: (additions) => {
        metadata = Object.assign(Object.assign({}, metadata), additions);
      }
    };
  }
});

// node_modules/@statsig/client-core/src/ClientInterfaces.js
var require_ClientInterfaces = __commonJS({
  "node_modules/@statsig/client-core/src/ClientInterfaces.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@statsig/client-core/src/UUID.js
var require_UUID = __commonJS({
  "node_modules/@statsig/client-core/src/UUID.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getUUID = void 0;
    function getUUID() {
      if (typeof crypto !== "undefined" && typeof crypto.randomUUID === "function") {
        return crypto.randomUUID();
      }
      let d = (/* @__PURE__ */ new Date()).getTime();
      let d2 = typeof performance !== "undefined" && performance.now && performance.now() * 1e3 || 0;
      const y = "89ab"[Math.floor(Math.random() * 4)];
      return `xxxxxxxx-xxxx-4xxx-${y}xxx-xxxxxxxxxxxx`.replace(/[xy]/g, (c) => {
        let r = Math.random() * 16;
        if (d > 0) {
          r = (d + r) % 16 | 0;
          d = Math.floor(d / 16);
        } else {
          r = (d2 + r) % 16 | 0;
          d2 = Math.floor(d2 / 16);
        }
        return (c === "x" ? r : r & 7 | 8).toString(16);
      });
    }
    exports.getUUID = getUUID;
  }
});

// node_modules/@statsig/client-core/src/StableID.js
var require_StableID = __commonJS({
  "node_modules/@statsig/client-core/src/StableID.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StableID = void 0;
    var CacheKey_1 = require_CacheKey();
    var Log_1 = require_Log();
    var SafeJs_1 = require_SafeJs();
    var StorageProvider_1 = require_StorageProvider();
    var UUID_1 = require_UUID();
    var PROMISE_MAP = {};
    var COOKIE_ENABLED_MAP = {};
    var DISABLED_MAP = {};
    exports.StableID = {
      cookiesEnabled: false,
      randomID: Math.random().toString(36),
      get: (sdkKey) => {
        if (DISABLED_MAP[sdkKey]) {
          return null;
        }
        if (PROMISE_MAP[sdkKey] != null) {
          return PROMISE_MAP[sdkKey];
        }
        let stableID = null;
        stableID = _loadFromCookie(sdkKey);
        if (stableID != null) {
          PROMISE_MAP[sdkKey] = stableID;
          _persistToStorage(stableID, sdkKey);
          return stableID;
        }
        stableID = _loadFromStorage(sdkKey);
        if (stableID == null) {
          stableID = (0, UUID_1.getUUID)();
        }
        _persistToStorage(stableID, sdkKey);
        _persistToCookie(stableID, sdkKey);
        PROMISE_MAP[sdkKey] = stableID;
        return stableID;
      },
      setOverride: (override, sdkKey) => {
        PROMISE_MAP[sdkKey] = override;
        _persistToStorage(override, sdkKey);
        _persistToCookie(override, sdkKey);
      },
      _setCookiesEnabled: (sdkKey, cookiesEnabled) => {
        COOKIE_ENABLED_MAP[sdkKey] = cookiesEnabled;
      },
      _setDisabled: (sdkKey, disabled) => {
        DISABLED_MAP[sdkKey] = disabled;
      }
    };
    function _getStableIDStorageKey(sdkKey) {
      return `statsig.stable_id.${(0, CacheKey_1._getStorageKey)(sdkKey)}`;
    }
    function _persistToStorage(stableID, sdkKey) {
      const storageKey = _getStableIDStorageKey(sdkKey);
      try {
        (0, StorageProvider_1._setObjectInStorage)(storageKey, stableID);
      } catch (e) {
        Log_1.Log.warn("Failed to save StableID to storage");
      }
    }
    function _loadFromStorage(sdkKey) {
      const storageKey = _getStableIDStorageKey(sdkKey);
      return (0, StorageProvider_1._getObjectFromStorage)(storageKey);
    }
    function _loadFromCookie(sdkKey) {
      if (!COOKIE_ENABLED_MAP[sdkKey] || (0, SafeJs_1._getDocumentSafe)() == null) {
        return null;
      }
      const cookies = document.cookie.split(";");
      for (const cookie of cookies) {
        const [key, value] = cookie.trim().split("=");
        if (key === _getCookieName(sdkKey)) {
          return decodeURIComponent(value);
        }
      }
      return null;
    }
    function _persistToCookie(stableID, sdkKey) {
      if (!COOKIE_ENABLED_MAP[sdkKey] || !document) {
        return;
      }
      const expiryDate = /* @__PURE__ */ new Date();
      expiryDate.setFullYear(expiryDate.getFullYear() + 1);
      document.cookie = `${_getCookieName(sdkKey)}=${encodeURIComponent(stableID)}; expires=${expiryDate.toUTCString()}; path=/`;
    }
    function _getCookieName(sdkKey) {
      return `statsig.stable_id.${(0, CacheKey_1._getStorageKey)(sdkKey)}`;
    }
  }
});

// node_modules/@statsig/client-core/src/StatsigUser.js
var require_StatsigUser = __commonJS({
  "node_modules/@statsig/client-core/src/StatsigUser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._getFullUserHash = exports._normalizeUser = void 0;
    var Hashing_1 = require_Hashing();
    var Log_1 = require_Log();
    function _normalizeUser(original, options, fallbackEnvironment) {
      try {
        const copy = JSON.parse(JSON.stringify(original));
        if (options != null && options.environment != null) {
          copy.statsigEnvironment = options.environment;
        } else if (fallbackEnvironment != null) {
          copy.statsigEnvironment = { tier: fallbackEnvironment };
        }
        return copy;
      } catch (error) {
        Log_1.Log.error("Failed to JSON.stringify user");
        return { statsigEnvironment: void 0 };
      }
    }
    exports._normalizeUser = _normalizeUser;
    function _getFullUserHash(user) {
      return user ? (0, Hashing_1._DJB2Object)(user) : null;
    }
    exports._getFullUserHash = _getFullUserHash;
  }
});

// node_modules/@statsig/client-core/src/TypedJsonParse.js
var require_TypedJsonParse = __commonJS({
  "node_modules/@statsig/client-core/src/TypedJsonParse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._typedJsonParse = void 0;
    var Log_1 = require_Log();
    function _typedJsonParse(data, guard, typeName) {
      try {
        const result = JSON.parse(data);
        if (result && typeof result === "object" && guard in result) {
          return result;
        }
      } catch (_a) {
      }
      Log_1.Log.error(`Failed to parse ${typeName}`);
      return null;
    }
    exports._typedJsonParse = _typedJsonParse;
  }
});

// node_modules/@statsig/client-core/src/DataAdapterCore.js
var require_DataAdapterCore = __commonJS({
  "node_modules/@statsig/client-core/src/DataAdapterCore.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._makeDataAdapterResult = exports.DataAdapterCore = void 0;
    var Log_1 = require_Log();
    var StableID_1 = require_StableID();
    var StatsigUser_1 = require_StatsigUser();
    var StorageProvider_1 = require_StorageProvider();
    var TypedJsonParse_1 = require_TypedJsonParse();
    var CACHE_LIMIT = 10;
    var DataAdapterCore = class {
      constructor(_adapterName, _cacheSuffix) {
        this._adapterName = _adapterName;
        this._cacheSuffix = _cacheSuffix;
        this._options = null;
        this._sdkKey = null;
        this._lastModifiedStoreKey = `statsig.last_modified_time.${_cacheSuffix}`;
        this._inMemoryCache = new InMemoryCache();
      }
      attach(sdkKey, options, _network) {
        this._sdkKey = sdkKey;
        this._options = options;
      }
      getDataSync(user) {
        const normalized = user && (0, StatsigUser_1._normalizeUser)(user, this._options);
        const cacheKey = this._getCacheKey(normalized);
        const inMem = this._inMemoryCache.get(cacheKey, normalized);
        if (inMem) {
          return inMem;
        }
        const cache = this._loadFromCache(cacheKey);
        if (cache) {
          this._inMemoryCache.add(cacheKey, cache);
          return this._inMemoryCache.get(cacheKey, normalized);
        }
        return null;
      }
      setData(data, user) {
        const normalized = user && (0, StatsigUser_1._normalizeUser)(user, this._options);
        const cacheKey = this._getCacheKey(normalized);
        this._inMemoryCache.add(cacheKey, _makeDataAdapterResult("Bootstrap", data, null, normalized));
      }
      _getDataAsyncImpl(current, user, options) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!StorageProvider_1.Storage.isReady()) {
            yield StorageProvider_1.Storage.isReadyResolver();
          }
          const cache = current !== null && current !== void 0 ? current : this.getDataSync(user);
          const ops = [this._fetchAndPrepFromNetwork(cache, user, options)];
          if (options === null || options === void 0 ? void 0 : options.timeoutMs) {
            ops.push(new Promise((r) => setTimeout(r, options.timeoutMs)).then(() => {
              Log_1.Log.debug("Fetching latest value timed out");
              return null;
            }));
          }
          return yield Promise.race(ops);
        });
      }
      _prefetchDataImpl(user, options) {
        return __awaiter(this, void 0, void 0, function* () {
          const normalized = user && (0, StatsigUser_1._normalizeUser)(user, this._options);
          const cacheKey = this._getCacheKey(normalized);
          const result = yield this._getDataAsyncImpl(null, normalized, options);
          if (result) {
            this._inMemoryCache.add(cacheKey, Object.assign(Object.assign({}, result), { source: "Prefetch" }));
          }
        });
      }
      _fetchAndPrepFromNetwork(cachedResult, user, options) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          const cachedData = (_a = cachedResult === null || cachedResult === void 0 ? void 0 : cachedResult.data) !== null && _a !== void 0 ? _a : null;
          const isCacheValidFor204 = cachedResult != null && this._isCachedResultValidFor204(cachedResult, user);
          const latest = yield this._fetchFromNetwork(cachedData, user, options, isCacheValidFor204);
          if (!latest) {
            Log_1.Log.debug("No response returned for latest value");
            return null;
          }
          const response = (0, TypedJsonParse_1._typedJsonParse)(latest, "has_updates", "Response");
          const sdkKey = this._getSdkKey();
          const stableID = StableID_1.StableID.get(sdkKey);
          let result = null;
          if ((response === null || response === void 0 ? void 0 : response.has_updates) === true) {
            result = _makeDataAdapterResult("Network", latest, stableID, user);
          } else if (cachedData && (response === null || response === void 0 ? void 0 : response.has_updates) === false) {
            result = _makeDataAdapterResult("NetworkNotModified", cachedData, stableID, user);
          } else {
            return null;
          }
          const cacheKey = this._getCacheKey(user);
          this._inMemoryCache.add(cacheKey, result);
          this._writeToCache(cacheKey, result);
          return result;
        });
      }
      _getSdkKey() {
        if (this._sdkKey != null) {
          return this._sdkKey;
        }
        Log_1.Log.error(`${this._adapterName} is not attached to a Client`);
        return "";
      }
      _loadFromCache(cacheKey) {
        var _a;
        const cache = (_a = StorageProvider_1.Storage.getItem) === null || _a === void 0 ? void 0 : _a.call(StorageProvider_1.Storage, cacheKey);
        if (cache == null) {
          return null;
        }
        const result = (0, TypedJsonParse_1._typedJsonParse)(cache, "source", "Cached Result");
        return result ? Object.assign(Object.assign({}, result), { source: "Cache" }) : null;
      }
      _writeToCache(cacheKey, result) {
        StorageProvider_1.Storage.setItem(cacheKey, JSON.stringify(result));
        this._runLocalStorageCacheEviction(cacheKey);
      }
      _runLocalStorageCacheEviction(cacheKey) {
        var _a;
        const lastModifiedTimeMap = (_a = (0, StorageProvider_1._getObjectFromStorage)(this._lastModifiedStoreKey)) !== null && _a !== void 0 ? _a : {};
        lastModifiedTimeMap[cacheKey] = Date.now();
        const evictable = _getEvictableKey(lastModifiedTimeMap, CACHE_LIMIT);
        if (evictable) {
          delete lastModifiedTimeMap[evictable];
          StorageProvider_1.Storage.removeItem(evictable);
        }
        (0, StorageProvider_1._setObjectInStorage)(this._lastModifiedStoreKey, lastModifiedTimeMap);
      }
    };
    exports.DataAdapterCore = DataAdapterCore;
    function _makeDataAdapterResult(source, data, stableID, user) {
      return {
        source,
        data,
        receivedAt: Date.now(),
        stableID,
        fullUserHash: (0, StatsigUser_1._getFullUserHash)(user)
      };
    }
    exports._makeDataAdapterResult = _makeDataAdapterResult;
    var InMemoryCache = class {
      constructor() {
        this._data = {};
      }
      get(cacheKey, user) {
        var _a;
        const result = this._data[cacheKey];
        const cached = result === null || result === void 0 ? void 0 : result.stableID;
        const provided = (_a = user === null || user === void 0 ? void 0 : user.customIDs) === null || _a === void 0 ? void 0 : _a.stableID;
        if (provided && cached && provided !== cached) {
          Log_1.Log.warn("'StatsigUser.customIDs.stableID' mismatch");
          return null;
        }
        return result;
      }
      add(cacheKey, value) {
        const oldest = _getEvictableKey(this._data, CACHE_LIMIT - 1);
        if (oldest) {
          delete this._data[oldest];
        }
        this._data[cacheKey] = value;
      }
      merge(values) {
        this._data = Object.assign(Object.assign({}, this._data), values);
      }
    };
    function _getEvictableKey(data, limit) {
      const keys = Object.keys(data);
      if (keys.length <= limit) {
        return null;
      }
      return keys.reduce((prevKey, currKey) => {
        const prev = data[prevKey];
        const current = data[currKey];
        if (typeof prev === "object" && typeof current === "object") {
          return current.receivedAt < prev.receivedAt ? currKey : prevKey;
        }
        return current < prev ? currKey : prevKey;
      });
    }
  }
});

// node_modules/@statsig/client-core/src/DownloadConfigSpecsResponse.js
var require_DownloadConfigSpecsResponse = __commonJS({
  "node_modules/@statsig/client-core/src/DownloadConfigSpecsResponse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@statsig/client-core/src/SDKType.js
var require_SDKType = __commonJS({
  "node_modules/@statsig/client-core/src/SDKType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SDKType = void 0;
    var SDK_CLIENT = {};
    var suffix;
    exports.SDKType = {
      _get: (sdkKey) => {
        var _a;
        return ((_a = SDK_CLIENT[sdkKey]) !== null && _a !== void 0 ? _a : "js-mono") + (suffix !== null && suffix !== void 0 ? suffix : "");
      },
      _setClientType(sdkKey, client) {
        SDK_CLIENT[sdkKey] = client;
      },
      _setBindingType(binding) {
        if (!suffix || suffix === "-react") {
          suffix = "-" + binding;
        }
      }
    };
  }
});

// node_modules/@statsig/client-core/src/ErrorBoundary.js
var require_ErrorBoundary = __commonJS({
  "node_modules/@statsig/client-core/src/ErrorBoundary.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ErrorBoundary = exports.EXCEPTION_ENDPOINT = void 0;
    var Log_1 = require_Log();
    var SDKType_1 = require_SDKType();
    var StatsigMetadata_1 = require_StatsigMetadata();
    exports.EXCEPTION_ENDPOINT = "https://statsigapi.net/v1/sdk_exception";
    var UNKNOWN_ERROR = "[Statsig] UnknownError";
    var ErrorBoundary = class {
      constructor(_sdkKey, _options, _emitter, _lastSeenError) {
        this._sdkKey = _sdkKey;
        this._options = _options;
        this._emitter = _emitter;
        this._lastSeenError = _lastSeenError;
        this._seen = /* @__PURE__ */ new Set();
      }
      wrap(instance) {
        try {
          const obj = instance;
          _getAllInstanceMethodNames(obj).forEach((name) => {
            const original = obj[name];
            if ("$EB" in original) {
              return;
            }
            obj[name] = (...args) => {
              return this._capture(name, () => original.apply(instance, args));
            };
            obj[name].$EB = true;
          });
        } catch (err) {
          this._onError("eb:wrap", err);
        }
      }
      logError(tag, error) {
        this._onError(tag, error);
      }
      getLastSeenErrorAndReset() {
        const tempError = this._lastSeenError;
        this._lastSeenError = void 0;
        return tempError !== null && tempError !== void 0 ? tempError : null;
      }
      attachErrorIfNoneExists(error) {
        if (this._lastSeenError) {
          return;
        }
        this._lastSeenError = _resolveError(error);
      }
      _capture(tag, task) {
        try {
          const res = task();
          if (res && res instanceof Promise) {
            return res.catch((err) => this._onError(tag, err));
          }
          return res;
        } catch (error) {
          this._onError(tag, error);
          return null;
        }
      }
      _onError(tag, error) {
        try {
          Log_1.Log.warn(`Caught error in ${tag}`, { error });
          const impl = () => __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e, _f, _g;
            const unwrapped = error ? error : Error(UNKNOWN_ERROR);
            const isError = unwrapped instanceof Error;
            const name = isError ? unwrapped.name : "No Name";
            const resolvedError = _resolveError(unwrapped);
            this._lastSeenError = resolvedError;
            if (this._seen.has(name)) {
              return;
            }
            this._seen.add(name);
            if ((_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.networkConfig) === null || _b === void 0 ? void 0 : _b.preventAllNetworkTraffic) {
              (_c = this._emitter) === null || _c === void 0 ? void 0 : _c.call(this, {
                name: "error",
                error,
                tag
              });
              return;
            }
            const sdkType = SDKType_1.SDKType._get(this._sdkKey);
            const statsigMetadata = StatsigMetadata_1.StatsigMetadataProvider.get();
            const info = isError ? unwrapped.stack : _getDescription(unwrapped);
            const body = Object.assign({ tag, exception: name, info, statsigOptions: _getStatsigOptionLoggingCopy(this._options) }, Object.assign(Object.assign({}, statsigMetadata), { sdkType }));
            const func = (_f = (_e = (_d = this._options) === null || _d === void 0 ? void 0 : _d.networkConfig) === null || _e === void 0 ? void 0 : _e.networkOverrideFunc) !== null && _f !== void 0 ? _f : fetch;
            yield func(exports.EXCEPTION_ENDPOINT, {
              method: "POST",
              headers: {
                "STATSIG-API-KEY": this._sdkKey,
                "STATSIG-SDK-TYPE": String(sdkType),
                "STATSIG-SDK-VERSION": String(statsigMetadata.sdkVersion),
                "Content-Type": "application/json"
              },
              body: JSON.stringify(body)
            });
            (_g = this._emitter) === null || _g === void 0 ? void 0 : _g.call(this, {
              name: "error",
              error,
              tag
            });
          });
          impl().then(() => {
          }).catch(() => {
          });
        } catch (_error) {
        }
      }
    };
    exports.ErrorBoundary = ErrorBoundary;
    function _resolveError(error) {
      if (error instanceof Error) {
        return error;
      } else if (typeof error === "string") {
        return new Error(error);
      } else {
        return new Error("An unknown error occurred.");
      }
    }
    function _getDescription(obj) {
      try {
        return JSON.stringify(obj);
      } catch (_a) {
        return UNKNOWN_ERROR;
      }
    }
    function _getAllInstanceMethodNames(instance) {
      const names = /* @__PURE__ */ new Set();
      let proto = Object.getPrototypeOf(instance);
      while (proto && proto !== Object.prototype) {
        Object.getOwnPropertyNames(proto).filter((prop) => typeof (proto === null || proto === void 0 ? void 0 : proto[prop]) === "function").forEach((name) => names.add(name));
        proto = Object.getPrototypeOf(proto);
      }
      return Array.from(names);
    }
    function _getStatsigOptionLoggingCopy(options) {
      if (!options) {
        return {};
      }
      const loggingCopy = {};
      Object.entries(options).forEach(([option, value]) => {
        const valueType = typeof value;
        switch (valueType) {
          case "number":
          case "bigint":
          case "boolean":
            loggingCopy[String(option)] = value;
            break;
          case "string":
            if (value.length < 50) {
              loggingCopy[String(option)] = value;
            } else {
              loggingCopy[String(option)] = "set";
            }
            break;
          case "object":
            if (option === "environment") {
              loggingCopy["environment"] = value;
            } else if (option === "networkConfig") {
              loggingCopy["networkConfig"] = value;
            } else {
              loggingCopy[String(option)] = value != null ? "set" : "unset";
            }
            break;
          default:
        }
      });
      return loggingCopy;
    }
  }
});

// node_modules/@statsig/client-core/src/EvaluationOptions.js
var require_EvaluationOptions = __commonJS({
  "node_modules/@statsig/client-core/src/EvaluationOptions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@statsig/client-core/src/EvaluationTypes.js
var require_EvaluationTypes = __commonJS({
  "node_modules/@statsig/client-core/src/EvaluationTypes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@statsig/client-core/src/InitializeResponse.js
var require_InitializeResponse = __commonJS({
  "node_modules/@statsig/client-core/src/InitializeResponse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@statsig/client-core/src/MemoKey.js
var require_MemoKey = __commonJS({
  "node_modules/@statsig/client-core/src/MemoKey.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createMemoKey = exports.MemoPrefix = void 0;
    exports.MemoPrefix = {
      _gate: "g",
      _dynamicConfig: "c",
      _experiment: "e",
      _layer: "l",
      _paramStore: "p"
    };
    var EXIST_KEYS = /* @__PURE__ */ new Set([
      // Add keys that should be memoized based only on their existence, not their value
    ]);
    var DO_NOT_MEMO_KEYS = /* @__PURE__ */ new Set([
      // Add keys that if exist, should not be memoized
      "userPersistedValues"
    ]);
    function createMemoKey(prefix, name, options) {
      let cacheKey = `${prefix}|${name}`;
      if (!options) {
        return cacheKey;
      }
      for (const key of Object.keys(options)) {
        if (DO_NOT_MEMO_KEYS.has(key)) {
          return void 0;
        }
        if (EXIST_KEYS.has(key)) {
          cacheKey += `|${key}=true`;
        } else {
          cacheKey += `|${key}=${options[key]}`;
        }
      }
      return cacheKey;
    }
    exports.createMemoKey = createMemoKey;
  }
});

// node_modules/@statsig/client-core/src/DnsTxtQuery.js
var require_DnsTxtQuery = __commonJS({
  "node_modules/@statsig/client-core/src/DnsTxtQuery.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._fetchTxtRecords = void 0;
    var FEATURE_ASSETS_DNS_QUERY = new Uint8Array([
      0,
      0,
      1,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      13,
      102,
      101,
      97,
      116,
      117,
      114,
      101,
      97,
      115,
      115,
      101,
      116,
      115,
      3,
      111,
      114,
      103,
      0,
      0,
      16,
      0,
      1
    ]);
    var DNS_QUERY_ENDPOINT = "https://cloudflare-dns.com/dns-query";
    var DOMAIN_CHARS = [
      "i",
      // initialize
      "e",
      // events
      "d"
      // dcs
    ];
    var MAX_START_LOOKUP = 200;
    function _fetchTxtRecords(networkFunc) {
      return __awaiter(this, void 0, void 0, function* () {
        const response = yield networkFunc(DNS_QUERY_ENDPOINT, {
          method: "POST",
          headers: {
            "Content-Type": "application/dns-message",
            Accept: "application/dns-message"
          },
          body: FEATURE_ASSETS_DNS_QUERY
        });
        if (!response.ok) {
          const err = new Error("Failed to fetch TXT records from DNS");
          err.name = "DnsTxtFetchError";
          throw err;
        }
        const data = yield response.arrayBuffer();
        const bytes = new Uint8Array(data);
        return _parseDnsResponse(bytes);
      });
    }
    exports._fetchTxtRecords = _fetchTxtRecords;
    function _parseDnsResponse(input) {
      const start = input.findIndex((byte, index) => index < MAX_START_LOOKUP && String.fromCharCode(byte) === "=" && DOMAIN_CHARS.includes(String.fromCharCode(input[index - 1])));
      if (start === -1) {
        const err = new Error("Failed to parse TXT records from DNS");
        err.name = "DnsTxtParseError";
        throw err;
      }
      let result = "";
      for (let i = start - 1; i < input.length; i++) {
        result += String.fromCharCode(input[i]);
      }
      return result.split(",");
    }
  }
});

// node_modules/@statsig/client-core/src/NetworkFallbackResolver.js
var require_NetworkFallbackResolver = __commonJS({
  "node_modules/@statsig/client-core/src/NetworkFallbackResolver.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._isDomainFailure = exports.NetworkFallbackResolver = void 0;
    var DnsTxtQuery_1 = require_DnsTxtQuery();
    var Hashing_1 = require_Hashing();
    var Log_1 = require_Log();
    var StorageProvider_1 = require_StorageProvider();
    var DEFAULT_TTL_MS = 7 * 24 * 60 * 60 * 1e3;
    var COOLDOWN_TIME_MS = 4 * 60 * 60 * 1e3;
    var NetworkFallbackResolver = class {
      constructor(options) {
        var _a;
        this._fallbackInfo = null;
        this._errorBoundary = null;
        this._dnsQueryCooldowns = {};
        this._networkOverrideFunc = (_a = options.networkConfig) === null || _a === void 0 ? void 0 : _a.networkOverrideFunc;
      }
      setErrorBoundary(errorBoundary) {
        this._errorBoundary = errorBoundary;
      }
      tryBumpExpiryTime(sdkKey, urlConfig) {
        var _a;
        const info = (_a = this._fallbackInfo) === null || _a === void 0 ? void 0 : _a[urlConfig.endpoint];
        if (!info) {
          return;
        }
        info.expiryTime = Date.now() + DEFAULT_TTL_MS;
        _tryWriteFallbackInfoToCache(sdkKey, Object.assign(Object.assign({}, this._fallbackInfo), { [urlConfig.endpoint]: info }));
      }
      getActiveFallbackUrl(sdkKey, urlConfig) {
        var _a, _b;
        if (urlConfig.customUrl != null && urlConfig.fallbackUrls != null) {
          return null;
        }
        let info = this._fallbackInfo;
        if (info == null) {
          info = (_a = _readFallbackInfoFromCache(sdkKey)) !== null && _a !== void 0 ? _a : {};
          this._fallbackInfo = info;
        }
        const entry = info[urlConfig.endpoint];
        if (!entry || Date.now() > ((_b = entry.expiryTime) !== null && _b !== void 0 ? _b : 0) || urlConfig.getChecksum() !== entry.urlConfigChecksum) {
          delete info[urlConfig.endpoint];
          this._fallbackInfo = info;
          _tryWriteFallbackInfoToCache(sdkKey, this._fallbackInfo);
          return null;
        }
        if (entry.url) {
          return entry.url;
        }
        return null;
      }
      tryFetchUpdatedFallbackInfo(sdkKey, urlConfig, errorMessage, timedOut) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
          try {
            if (!_isDomainFailure(errorMessage, timedOut)) {
              return false;
            }
            const canUseNetworkFallbacks = urlConfig.customUrl == null && urlConfig.fallbackUrls == null;
            const urls = canUseNetworkFallbacks ? yield this._tryFetchFallbackUrlsFromNetwork(urlConfig) : urlConfig.fallbackUrls;
            const newUrl = this._pickNewFallbackUrl((_a = this._fallbackInfo) === null || _a === void 0 ? void 0 : _a[urlConfig.endpoint], urls);
            if (!newUrl) {
              return false;
            }
            this._updateFallbackInfoWithNewUrl(sdkKey, urlConfig, newUrl);
            return true;
          } catch (error) {
            (_b = this._errorBoundary) === null || _b === void 0 ? void 0 : _b.logError("tryFetchUpdatedFallbackInfo", error);
            return false;
          }
        });
      }
      _updateFallbackInfoWithNewUrl(sdkKey, urlConfig, newUrl) {
        var _a, _b, _c;
        const newFallbackInfo = {
          urlConfigChecksum: urlConfig.getChecksum(),
          url: newUrl,
          expiryTime: Date.now() + DEFAULT_TTL_MS,
          previous: []
        };
        const endpoint = urlConfig.endpoint;
        const previousInfo = (_a = this._fallbackInfo) === null || _a === void 0 ? void 0 : _a[endpoint];
        if (previousInfo) {
          newFallbackInfo.previous.push(...previousInfo.previous);
        }
        if (newFallbackInfo.previous.length > 10) {
          newFallbackInfo.previous = [];
        }
        const previousUrl = (_c = (_b = this._fallbackInfo) === null || _b === void 0 ? void 0 : _b[endpoint]) === null || _c === void 0 ? void 0 : _c.url;
        if (previousUrl != null) {
          newFallbackInfo.previous.push(previousUrl);
        }
        this._fallbackInfo = Object.assign(Object.assign({}, this._fallbackInfo), { [endpoint]: newFallbackInfo });
        _tryWriteFallbackInfoToCache(sdkKey, this._fallbackInfo);
      }
      _tryFetchFallbackUrlsFromNetwork(urlConfig) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          const cooldown = this._dnsQueryCooldowns[urlConfig.endpoint];
          if (cooldown && Date.now() < cooldown) {
            return null;
          }
          this._dnsQueryCooldowns[urlConfig.endpoint] = Date.now() + COOLDOWN_TIME_MS;
          const result = [];
          const records = yield (0, DnsTxtQuery_1._fetchTxtRecords)((_a = this._networkOverrideFunc) !== null && _a !== void 0 ? _a : fetch);
          const path = _extractPathFromUrl(urlConfig.defaultUrl);
          for (const record of records) {
            if (!record.startsWith(urlConfig.endpointDnsKey + "=")) {
              continue;
            }
            const parts = record.split("=");
            if (parts.length > 1) {
              let baseUrl = parts[1];
              if (baseUrl.endsWith("/")) {
                baseUrl = baseUrl.slice(0, -1);
              }
              result.push(`https://${baseUrl}${path}`);
            }
          }
          return result;
        });
      }
      _pickNewFallbackUrl(currentFallbackInfo, urls) {
        var _a;
        if (urls == null) {
          return null;
        }
        const previouslyUsed = new Set((_a = currentFallbackInfo === null || currentFallbackInfo === void 0 ? void 0 : currentFallbackInfo.previous) !== null && _a !== void 0 ? _a : []);
        const currentFallbackUrl = currentFallbackInfo === null || currentFallbackInfo === void 0 ? void 0 : currentFallbackInfo.url;
        let found = null;
        for (const loopUrl of urls) {
          const url = loopUrl.endsWith("/") ? loopUrl.slice(0, -1) : loopUrl;
          if (!previouslyUsed.has(loopUrl) && url !== currentFallbackUrl) {
            found = url;
            break;
          }
        }
        return found;
      }
    };
    exports.NetworkFallbackResolver = NetworkFallbackResolver;
    function _isDomainFailure(errorMsg, timedOut) {
      var _a;
      const lowerErrorMsg = (_a = errorMsg === null || errorMsg === void 0 ? void 0 : errorMsg.toLowerCase()) !== null && _a !== void 0 ? _a : "";
      return timedOut || lowerErrorMsg.includes("uncaught exception") || lowerErrorMsg.includes("failed to fetch") || lowerErrorMsg.includes("networkerror when attempting to fetch resource");
    }
    exports._isDomainFailure = _isDomainFailure;
    function _getFallbackInfoStorageKey(sdkKey) {
      return `statsig.network_fallback.${(0, Hashing_1._DJB2)(sdkKey)}`;
    }
    function _tryWriteFallbackInfoToCache(sdkKey, info) {
      const hashKey = _getFallbackInfoStorageKey(sdkKey);
      if (!info || Object.keys(info).length === 0) {
        StorageProvider_1.Storage.removeItem(hashKey);
        return;
      }
      StorageProvider_1.Storage.setItem(hashKey, JSON.stringify(info));
    }
    function _readFallbackInfoFromCache(sdkKey) {
      const hashKey = _getFallbackInfoStorageKey(sdkKey);
      const data = StorageProvider_1.Storage.getItem(hashKey);
      if (!data) {
        return null;
      }
      try {
        return JSON.parse(data);
      } catch (_a) {
        Log_1.Log.error("Failed to parse FallbackInfo");
        return null;
      }
    }
    function _extractPathFromUrl(urlString) {
      try {
        const url = new URL(urlString);
        return url.pathname;
      } catch (error) {
        return null;
      }
    }
  }
});

// node_modules/@statsig/client-core/src/SDKFlags.js
var require_SDKFlags = __commonJS({
  "node_modules/@statsig/client-core/src/SDKFlags.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SDKFlags = void 0;
    var FLAGMAP = {};
    exports.SDKFlags = {
      setFlags: (sdkKey, flags) => {
        FLAGMAP[sdkKey] = flags;
      },
      get: (sdkKey, flagKey) => {
        var _a, _b;
        return (_b = (_a = FLAGMAP[sdkKey]) === null || _a === void 0 ? void 0 : _a[flagKey]) !== null && _b !== void 0 ? _b : false;
      }
    };
  }
});

// node_modules/@statsig/client-core/src/SessionID.js
var require_SessionID = __commonJS({
  "node_modules/@statsig/client-core/src/SessionID.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StatsigSession = exports.SessionID = void 0;
    var __StatsigGlobal_1 = require_StatsigGlobal();
    var CacheKey_1 = require_CacheKey();
    var Log_1 = require_Log();
    var StorageProvider_1 = require_StorageProvider();
    var UUID_1 = require_UUID();
    var MAX_SESSION_IDLE_TIME = 30 * 60 * 1e3;
    var MAX_SESSION_AGE = 4 * 60 * 60 * 1e3;
    var PROMISE_MAP = {};
    exports.SessionID = {
      get: (sdkKey) => {
        return exports.StatsigSession.get(sdkKey).data.sessionID;
      }
    };
    exports.StatsigSession = {
      get: (sdkKey) => {
        if (PROMISE_MAP[sdkKey] == null) {
          PROMISE_MAP[sdkKey] = _loadSession(sdkKey);
        }
        const session = PROMISE_MAP[sdkKey];
        return _bumpSession(session);
      },
      overrideInitialSessionID: (override, sdkKey) => {
        PROMISE_MAP[sdkKey] = _overrideSessionId(override, sdkKey);
      }
    };
    function _loadSession(sdkKey) {
      let data = _loadFromStorage(sdkKey);
      const now = Date.now();
      if (!data) {
        data = {
          sessionID: (0, UUID_1.getUUID)(),
          startTime: now,
          lastUpdate: now
        };
      }
      return {
        data,
        sdkKey
      };
    }
    function _overrideSessionId(override, sdkKey) {
      const now = Date.now();
      return {
        data: {
          sessionID: override,
          startTime: now,
          lastUpdate: now
        },
        sdkKey
      };
    }
    function _bumpSession(session) {
      const now = Date.now();
      const data = session.data;
      const sdkKey = session.sdkKey;
      if (_isIdle(data) || _hasRunTooLong(data)) {
        data.sessionID = (0, UUID_1.getUUID)();
        data.startTime = now;
        const client = __STATSIG__ === null || __STATSIG__ === void 0 ? void 0 : __STATSIG__.instance(sdkKey);
        if (client) {
          client.$emt({ name: "session_expired" });
        }
      }
      data.lastUpdate = now;
      _persistToStorage(data, session.sdkKey);
      clearTimeout(session.idleTimeoutID);
      clearTimeout(session.ageTimeoutID);
      const lifetime = now - data.startTime;
      session.idleTimeoutID = _createSessionTimeout(sdkKey, MAX_SESSION_IDLE_TIME);
      session.ageTimeoutID = _createSessionTimeout(sdkKey, MAX_SESSION_AGE - lifetime);
      return session;
    }
    function _createSessionTimeout(sdkKey, duration) {
      return setTimeout(() => {
        var _a;
        const client = (_a = (0, __StatsigGlobal_1._getStatsigGlobal)()) === null || _a === void 0 ? void 0 : _a.instance(sdkKey);
        if (client) {
          client.$emt({ name: "session_expired" });
        }
      }, duration);
    }
    function _isIdle({ lastUpdate }) {
      return Date.now() - lastUpdate > MAX_SESSION_IDLE_TIME;
    }
    function _hasRunTooLong({ startTime }) {
      return Date.now() - startTime > MAX_SESSION_AGE;
    }
    function _getSessionIDStorageKey(sdkKey) {
      return `statsig.session_id.${(0, CacheKey_1._getStorageKey)(sdkKey)}`;
    }
    function _persistToStorage(session, sdkKey) {
      const storageKey = _getSessionIDStorageKey(sdkKey);
      try {
        (0, StorageProvider_1._setObjectInStorage)(storageKey, session);
      } catch (e) {
        Log_1.Log.warn("Failed to save SessionID");
      }
    }
    function _loadFromStorage(sdkKey) {
      const storageKey = _getSessionIDStorageKey(sdkKey);
      return (0, StorageProvider_1._getObjectFromStorage)(storageKey);
    }
  }
});

// node_modules/@statsig/client-core/src/StatsigClientEventEmitter.js
var require_StatsigClientEventEmitter = __commonJS({
  "node_modules/@statsig/client-core/src/StatsigClientEventEmitter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ErrorTag = void 0;
    exports.ErrorTag = {
      NetworkError: "NetworkError"
    };
  }
});

// node_modules/@statsig/client-core/src/NetworkCore.js
var require_NetworkCore = __commonJS({
  "node_modules/@statsig/client-core/src/NetworkCore.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NetworkCore = void 0;
    require_StatsigGlobal();
    var __StatsigGlobal_1 = require_StatsigGlobal();
    var Diagnostics_1 = require_Diagnostics();
    var Log_1 = require_Log();
    var NetworkConfig_1 = require_NetworkConfig();
    var NetworkFallbackResolver_1 = require_NetworkFallbackResolver();
    var SDKFlags_1 = require_SDKFlags();
    var SDKType_1 = require_SDKType();
    var SafeJs_1 = require_SafeJs();
    var SessionID_1 = require_SessionID();
    var StableID_1 = require_StableID();
    var StatsigClientEventEmitter_1 = require_StatsigClientEventEmitter();
    var StatsigMetadata_1 = require_StatsigMetadata();
    var StatsigOptionsCommon_1 = require_StatsigOptionsCommon();
    var VisibilityObserving_1 = require_VisibilityObserving();
    var DEFAULT_TIMEOUT_MS = 1e4;
    var BACKOFF_BASE_MS = 500;
    var BACKOFF_MAX_MS = 3e4;
    var RATE_LIMIT_WINDOW_MS = 1e3;
    var RATE_LIMIT_MAX_REQ_COUNT = 50;
    var LEAK_RATE = RATE_LIMIT_MAX_REQ_COUNT / RATE_LIMIT_WINDOW_MS;
    var RETRYABLE_CODES = /* @__PURE__ */ new Set([408, 500, 502, 503, 504, 522, 524, 599]);
    var NetworkCore = class {
      constructor(options, _emitter) {
        this._emitter = _emitter;
        this._errorBoundary = null;
        this._timeout = DEFAULT_TIMEOUT_MS;
        this._netConfig = {};
        this._options = {};
        this._leakyBucket = {};
        this._lastUsedInitUrl = null;
        if (options) {
          this._options = options;
        }
        if (this._options.networkConfig) {
          this._netConfig = this._options.networkConfig;
        }
        if (this._netConfig.networkTimeoutMs) {
          this._timeout = this._netConfig.networkTimeoutMs;
        }
        this._fallbackResolver = new NetworkFallbackResolver_1.NetworkFallbackResolver(this._options);
        this.setLogEventCompressionMode(this._getLogEventCompressionMode(options));
      }
      setLogEventCompressionMode(mode) {
        this._options.logEventCompressionMode = mode;
      }
      setErrorBoundary(errorBoundary) {
        this._errorBoundary = errorBoundary;
        this._errorBoundary.wrap(this);
        this._errorBoundary.wrap(this._fallbackResolver);
        this._fallbackResolver.setErrorBoundary(errorBoundary);
      }
      isBeaconSupported() {
        return typeof navigator !== "undefined" && typeof navigator.sendBeacon === "function";
      }
      getLastUsedInitUrlAndReset() {
        const tempUrl = this._lastUsedInitUrl;
        this._lastUsedInitUrl = null;
        return tempUrl;
      }
      beacon(args) {
        if (!_ensureValidSdkKey(args)) {
          return false;
        }
        const argsInternal = this._getInternalRequestArgs("POST", args);
        const url = this._getPopulatedURL(argsInternal);
        const nav = navigator;
        return nav.sendBeacon.bind(nav)(url, argsInternal.body);
      }
      post(args) {
        return __awaiter(this, void 0, void 0, function* () {
          const argsInternal = this._getInternalRequestArgs("POST", args);
          this._tryEncodeBody(argsInternal);
          yield this._tryToCompressBody(argsInternal);
          return this._sendRequest(argsInternal);
        });
      }
      get(args) {
        const argsInternal = this._getInternalRequestArgs("GET", args);
        return this._sendRequest(argsInternal);
      }
      _sendRequest(args) {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
          if (!_ensureValidSdkKey(args)) {
            return null;
          }
          if (this._netConfig.preventAllNetworkTraffic) {
            return null;
          }
          const { method, body, retries, attempt } = args;
          const endpoint = args.urlConfig.endpoint;
          if (this._isRateLimited(endpoint)) {
            Log_1.Log.warn(`Request to ${endpoint} was blocked because you are making requests too frequently.`);
            return null;
          }
          const currentAttempt = attempt !== null && attempt !== void 0 ? attempt : 1;
          const abortController = typeof AbortController !== "undefined" ? new AbortController() : null;
          const timeoutHandle = setTimeout(() => {
            abortController === null || abortController === void 0 ? void 0 : abortController.abort(`Timeout of ${this._timeout}ms expired.`);
          }, this._timeout);
          const populatedUrl = this._getPopulatedURL(args);
          let response = null;
          const keepalive = (0, VisibilityObserving_1._isUnloading)();
          try {
            const config = {
              method,
              body,
              headers: Object.assign({}, args.headers),
              signal: abortController === null || abortController === void 0 ? void 0 : abortController.signal,
              priority: args.priority,
              keepalive
            };
            _tryMarkInitStart(args, currentAttempt);
            const bucket = this._leakyBucket[endpoint];
            if (bucket) {
              bucket.lastRequestTime = Date.now();
              this._leakyBucket[endpoint] = bucket;
            }
            const func = (_a = this._netConfig.networkOverrideFunc) !== null && _a !== void 0 ? _a : fetch;
            response = yield func(populatedUrl, config);
            clearTimeout(timeoutHandle);
            if (!response.ok) {
              const text2 = yield response.text().catch(() => "No Text");
              const err = new Error(`NetworkError: ${populatedUrl} ${text2}`);
              err.name = "NetworkError";
              throw err;
            }
            const text = yield response.text();
            _tryMarkInitEnd(args, response, currentAttempt, text);
            this._fallbackResolver.tryBumpExpiryTime(args.sdkKey, args.urlConfig);
            return {
              body: text,
              code: response.status
            };
          } catch (error) {
            const errorMessage = _getErrorMessage(abortController, error);
            const timedOut = _didTimeout(abortController);
            _tryMarkInitEnd(args, response, currentAttempt, "", error);
            const fallbackUpdated = yield this._fallbackResolver.tryFetchUpdatedFallbackInfo(args.sdkKey, args.urlConfig, errorMessage, timedOut);
            if (fallbackUpdated) {
              args.fallbackUrl = this._fallbackResolver.getActiveFallbackUrl(args.sdkKey, args.urlConfig);
            }
            if (!retries || currentAttempt > retries || !RETRYABLE_CODES.has((_b = response === null || response === void 0 ? void 0 : response.status) !== null && _b !== void 0 ? _b : 500)) {
              (_c = this._emitter) === null || _c === void 0 ? void 0 : _c.call(this, {
                name: "error",
                error,
                tag: StatsigClientEventEmitter_1.ErrorTag.NetworkError,
                requestArgs: args
              });
              const formattedErrorMsg = `A networking error occurred during ${method} request to ${populatedUrl}.`;
              Log_1.Log.error(formattedErrorMsg, errorMessage, error);
              (_d = this._errorBoundary) === null || _d === void 0 ? void 0 : _d.attachErrorIfNoneExists(formattedErrorMsg);
              return null;
            }
            yield _exponentialBackoff(currentAttempt);
            return this._sendRequest(Object.assign(Object.assign({}, args), { retries, attempt: currentAttempt + 1 }));
          }
        });
      }
      _getLogEventCompressionMode(options) {
        let compressionMode = options === null || options === void 0 ? void 0 : options.logEventCompressionMode;
        if (!compressionMode && (options === null || options === void 0 ? void 0 : options.disableCompression) === true) {
          compressionMode = StatsigOptionsCommon_1.LogEventCompressionMode.Disabled;
        }
        if (!compressionMode) {
          compressionMode = StatsigOptionsCommon_1.LogEventCompressionMode.Enabled;
        }
        return compressionMode;
      }
      _isRateLimited(endpoint) {
        var _a;
        const now = Date.now();
        const bucket = (_a = this._leakyBucket[endpoint]) !== null && _a !== void 0 ? _a : {
          count: 0,
          lastRequestTime: now
        };
        const elapsed = now - bucket.lastRequestTime;
        const leakedRequests = Math.floor(elapsed * LEAK_RATE);
        bucket.count = Math.max(0, bucket.count - leakedRequests);
        if (bucket.count >= RATE_LIMIT_MAX_REQ_COUNT) {
          return true;
        }
        bucket.count += 1;
        bucket.lastRequestTime = now;
        this._leakyBucket[endpoint] = bucket;
        return false;
      }
      _getPopulatedURL(args) {
        var _a;
        const url = (_a = args.fallbackUrl) !== null && _a !== void 0 ? _a : args.urlConfig.getUrl();
        if (args.urlConfig.endpoint === NetworkConfig_1.Endpoint._initialize || args.urlConfig.endpoint === NetworkConfig_1.Endpoint._download_config_specs) {
          this._lastUsedInitUrl = url;
        }
        const params = Object.assign({ [NetworkConfig_1.NetworkParam.SdkKey]: args.sdkKey, [NetworkConfig_1.NetworkParam.SdkType]: SDKType_1.SDKType._get(args.sdkKey), [NetworkConfig_1.NetworkParam.SdkVersion]: StatsigMetadata_1.SDK_VERSION, [NetworkConfig_1.NetworkParam.Time]: String(Date.now()), [NetworkConfig_1.NetworkParam.SessionID]: SessionID_1.SessionID.get(args.sdkKey) }, args.params);
        const query = Object.keys(params).map((key) => {
          return `${encodeURIComponent(key)}=${encodeURIComponent(params[key])}`;
        }).join("&");
        return `${url}${query ? `?${query}` : ""}`;
      }
      _tryEncodeBody(args) {
        var _a;
        const win = (0, SafeJs_1._getWindowSafe)();
        const body = args.body;
        if (!args.isStatsigEncodable || this._options.disableStatsigEncoding || typeof body !== "string" || (0, __StatsigGlobal_1._getStatsigGlobalFlag)("no-encode") != null || !(win === null || win === void 0 ? void 0 : win.btoa)) {
          return;
        }
        try {
          args.body = win.btoa(body).split("").reverse().join("");
          args.params = Object.assign(Object.assign({}, (_a = args.params) !== null && _a !== void 0 ? _a : {}), { [NetworkConfig_1.NetworkParam.StatsigEncoded]: "1" });
        } catch (e) {
          Log_1.Log.warn(`Request encoding failed for ${args.urlConfig.getUrl()}`, e);
        }
      }
      _tryToCompressBody(args) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          const body = args.body;
          if (typeof body !== "string" || !_allowCompression(args, this._options)) {
            return;
          }
          try {
            const bytes = new TextEncoder().encode(body);
            const stream = new CompressionStream("gzip");
            const writer = stream.writable.getWriter();
            writer.write(bytes).catch(Log_1.Log.error);
            writer.close().catch(Log_1.Log.error);
            const reader = stream.readable.getReader();
            const chunks = [];
            let result;
            while (!(result = yield reader.read()).done) {
              chunks.push(result.value);
            }
            const totalLength = chunks.reduce((acc, chunk) => acc + chunk.length, 0);
            const combined = new Uint8Array(totalLength);
            let offset = 0;
            for (const chunk of chunks) {
              combined.set(chunk, offset);
              offset += chunk.length;
            }
            args.body = combined;
            args.params = Object.assign(Object.assign({}, (_a = args.params) !== null && _a !== void 0 ? _a : {}), { [NetworkConfig_1.NetworkParam.IsGzipped]: "1" });
          } catch (e) {
            Log_1.Log.warn(`Request compression failed for ${args.urlConfig.getUrl()}`, e);
          }
        });
      }
      _getInternalRequestArgs(method, args) {
        const fallbackUrl = this._fallbackResolver.getActiveFallbackUrl(args.sdkKey, args.urlConfig);
        const result = Object.assign(Object.assign({}, args), {
          method,
          fallbackUrl
        });
        if ("data" in args) {
          _populateRequestBody(result, args.data);
        }
        return result;
      }
    };
    exports.NetworkCore = NetworkCore;
    var _ensureValidSdkKey = (args) => {
      if (!args.sdkKey) {
        Log_1.Log.warn("Unable to make request without an SDK key");
        return false;
      }
      return true;
    };
    var _populateRequestBody = (args, data) => {
      const { sdkKey, fallbackUrl } = args;
      const stableID = StableID_1.StableID.get(sdkKey);
      const sessionID = SessionID_1.SessionID.get(sdkKey);
      const sdkType = SDKType_1.SDKType._get(sdkKey);
      args.body = JSON.stringify(Object.assign(Object.assign({}, data), { statsigMetadata: Object.assign(Object.assign({}, StatsigMetadata_1.StatsigMetadataProvider.get()), {
        stableID,
        sessionID,
        sdkType,
        fallbackUrl
      }) }));
    };
    function _allowCompression(args, options) {
      if (!args.isCompressable) {
        return false;
      }
      if ((0, __StatsigGlobal_1._getStatsigGlobalFlag)("no-compress") != null || typeof CompressionStream === "undefined" || typeof TextEncoder === "undefined") {
        return false;
      }
      const isProxy = args.urlConfig.customUrl != null || args.urlConfig.fallbackUrls != null;
      const flagEnabled = SDKFlags_1.SDKFlags.get(args.sdkKey, "enable_log_event_compression") === true;
      switch (options.logEventCompressionMode) {
        case StatsigOptionsCommon_1.LogEventCompressionMode.Disabled:
          return false;
        case StatsigOptionsCommon_1.LogEventCompressionMode.Enabled:
          if (isProxy && !flagEnabled) {
            return false;
          }
          return true;
        case StatsigOptionsCommon_1.LogEventCompressionMode.Forced:
          return true;
        default:
          return false;
      }
    }
    function _getErrorMessage(controller, error) {
      if ((controller === null || controller === void 0 ? void 0 : controller.signal.aborted) && typeof controller.signal.reason === "string") {
        return controller.signal.reason;
      }
      if (typeof error === "string") {
        return error;
      }
      if (error instanceof Error) {
        return `${error.name}: ${error.message}`;
      }
      return "Unknown Error";
    }
    function _didTimeout(controller) {
      const timeout = (controller === null || controller === void 0 ? void 0 : controller.signal.aborted) && typeof controller.signal.reason === "string" && controller.signal.reason.includes("Timeout");
      return timeout || false;
    }
    function _tryMarkInitStart(args, attempt) {
      if (args.urlConfig.endpoint !== NetworkConfig_1.Endpoint._initialize) {
        return;
      }
      Diagnostics_1.Diagnostics._markInitNetworkReqStart(args.sdkKey, {
        attempt
      });
    }
    function _tryMarkInitEnd(args, response, attempt, body, err) {
      if (args.urlConfig.endpoint !== NetworkConfig_1.Endpoint._initialize) {
        return;
      }
      Diagnostics_1.Diagnostics._markInitNetworkReqEnd(args.sdkKey, Diagnostics_1.Diagnostics._getDiagnosticsData(response, attempt, body, err));
    }
    function _exponentialBackoff(attempt) {
      return __awaiter(this, void 0, void 0, function* () {
        yield new Promise((r) => setTimeout(r, Math.min(BACKOFF_BASE_MS * (attempt * attempt), BACKOFF_MAX_MS)));
      });
    }
  }
});

// node_modules/@statsig/client-core/src/OverrideAdapter.js
var require_OverrideAdapter = __commonJS({
  "node_modules/@statsig/client-core/src/OverrideAdapter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@statsig/client-core/src/ParamStoreTypes.js
var require_ParamStoreTypes = __commonJS({
  "node_modules/@statsig/client-core/src/ParamStoreTypes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@statsig/client-core/src/StatsigClientBase.js
var require_StatsigClientBase = __commonJS({
  "node_modules/@statsig/client-core/src/StatsigClientBase.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StatsigClientBase = void 0;
    require_StatsigGlobal();
    var __StatsigGlobal_1 = require_StatsigGlobal();
    var ErrorBoundary_1 = require_ErrorBoundary();
    var EventLogger_1 = require_EventLogger();
    var Log_1 = require_Log();
    var MemoKey_1 = require_MemoKey();
    var SafeJs_1 = require_SafeJs();
    var SessionID_1 = require_SessionID();
    var StableID_1 = require_StableID();
    var StatsigOptionsCommon_1 = require_StatsigOptionsCommon();
    var StorageProvider_1 = require_StorageProvider();
    var MAX_MEMO_CACHE_SIZE = 3e3;
    var StatsigClientBase = class {
      constructor(sdkKey, adapter, network, options) {
        var _a, _b, _c, _d;
        this.loadingStatus = "Uninitialized";
        this._initializePromise = null;
        this._listeners = {};
        const emitter = this.$emt.bind(this);
        (options === null || options === void 0 ? void 0 : options.logLevel) != null && (Log_1.Log.level = options.logLevel);
        (options === null || options === void 0 ? void 0 : options.disableStorage) && StorageProvider_1.Storage._setDisabled(true);
        (options === null || options === void 0 ? void 0 : options.initialSessionID) && SessionID_1.StatsigSession.overrideInitialSessionID(options.initialSessionID, sdkKey);
        (options === null || options === void 0 ? void 0 : options.storageProvider) && StorageProvider_1.Storage._setProvider(options.storageProvider);
        (options === null || options === void 0 ? void 0 : options.enableCookies) && StableID_1.StableID._setCookiesEnabled(sdkKey, options.enableCookies);
        (options === null || options === void 0 ? void 0 : options.disableStableID) && StableID_1.StableID._setDisabled(sdkKey, true);
        this._sdkKey = sdkKey;
        this._options = options !== null && options !== void 0 ? options : {};
        this._memoCache = {};
        this.overrideAdapter = (_a = options === null || options === void 0 ? void 0 : options.overrideAdapter) !== null && _a !== void 0 ? _a : null;
        this._logger = new EventLogger_1.EventLogger(sdkKey, emitter, network, options);
        this._errorBoundary = new ErrorBoundary_1.ErrorBoundary(sdkKey, options, emitter);
        this._errorBoundary.wrap(this);
        this._errorBoundary.wrap(adapter);
        this._errorBoundary.wrap(this._logger);
        network.setErrorBoundary(this._errorBoundary);
        this.dataAdapter = adapter;
        this.dataAdapter.attach(sdkKey, options, network);
        this.storageProvider = StorageProvider_1.Storage;
        (_d = (_c = (_b = this.overrideAdapter) === null || _b === void 0 ? void 0 : _b.loadFromStorage) === null || _c === void 0 ? void 0 : _c.call(_b)) === null || _d === void 0 ? void 0 : _d.catch((e) => this._errorBoundary.logError("OA::loadFromStorage", e));
        this._primeReadyRipcord();
        _assignGlobalInstance(sdkKey, this);
      }
      /**
       * Updates runtime configuration options for the SDK, allowing toggling of certain behaviors such as logging and storage to comply with user preferences or regulations such as GDPR.
       *
       * @param {StatsigRuntimeMutableOptions} options - The configuration options that dictate the runtime behavior of the SDK.
       */
      updateRuntimeOptions(options) {
        if (options.loggingEnabled) {
          this._options.loggingEnabled = options.loggingEnabled;
          this._logger.setLoggingEnabled(options.loggingEnabled);
        } else if (options.disableLogging != null) {
          this._options.disableLogging = options.disableLogging;
          this._logger.setLoggingEnabled(options.disableLogging ? "disabled" : "browser-only");
        }
        if (options.disableStorage != null) {
          this._options.disableStorage = options.disableStorage;
          StorageProvider_1.Storage._setDisabled(options.disableStorage);
        }
        if (options.enableCookies != null) {
          this._options.enableCookies = options.enableCookies;
          StableID_1.StableID._setCookiesEnabled(this._sdkKey, options.enableCookies);
        }
        if (options.logEventCompressionMode) {
          this._logger.setLogEventCompressionMode(options.logEventCompressionMode);
        } else if (options.disableCompression) {
          this._logger.setLogEventCompressionMode(StatsigOptionsCommon_1.LogEventCompressionMode.Disabled);
        }
      }
      /**
       * Flushes any currently queued events.
       */
      flush() {
        return this._logger.flush();
      }
      /**
       * Gracefully shuts down the SDK, ensuring that all pending events are send before the SDK stops.
       * This function emits a 'pre_shutdown' event and then waits for the logger to complete its shutdown process.
       *
       * @returns {Promise<void>} A promise that resolves when all shutdown procedures, including logging shutdown, have been completed.
       */
      shutdown() {
        return __awaiter(this, void 0, void 0, function* () {
          this.$emt({ name: "pre_shutdown" });
          this._setStatus("Uninitialized", null);
          this._initializePromise = null;
          yield this._logger.stop();
        });
      }
      /**
       * Subscribes a callback function to a specific {@link StatsigClientEvent} or all StatsigClientEvents if the wildcard '*' is used.
       * Once subscribed, the listener callback will be invoked whenever the specified event is emitted.
       *
       * @param {StatsigClientEventName} event - The name of the event to subscribe to, or '*' to subscribe to all events.
       * @param {StatsigClientEventCallback<T>} listener - The callback function to execute when the event occurs. The function receives event-specific data as its parameter.
       * @see {@link off} for unsubscribing from events.
       */
      on(event, listener) {
        if (!this._listeners[event]) {
          this._listeners[event] = [];
        }
        this._listeners[event].push(listener);
      }
      /**
       * Unsubscribes a previously registered callback function from a specific {@link StatsigClientEvent} or all StatsigClientEvents if the wildcard '*' is used.
       *
       * @param {StatsigClientEventName} event - The name of the event from which to unsubscribe, or '*' to unsubscribe from all events.
       * @param {StatsigClientEventCallback<T>} listener - The callback function to remove from the event's notification list.
       * @see {@link on} for subscribing to events.
       */
      off(event, listener) {
        if (this._listeners[event]) {
          const index = this._listeners[event].indexOf(listener);
          if (index !== -1) {
            this._listeners[event].splice(index, 1);
          }
        }
      }
      $on(event, listener) {
        listener.__isInternal = true;
        this.on(event, listener);
      }
      $emt(event) {
        var _a;
        const barrier = (listener) => {
          try {
            listener(event);
          } catch (error) {
            if (listener.__isInternal === true) {
              this._errorBoundary.logError(`__emit:${event.name}`, error);
              return;
            }
            Log_1.Log.error(`An error occurred in a StatsigClientEvent listener. This is not an issue with Statsig.`, event);
          }
        };
        if (this._listeners[event.name]) {
          this._listeners[event.name].forEach((l) => barrier(l));
        }
        (_a = this._listeners["*"]) === null || _a === void 0 ? void 0 : _a.forEach(barrier);
      }
      _setStatus(newStatus, values) {
        this.loadingStatus = newStatus;
        this._memoCache = {};
        this.$emt({ name: "values_updated", status: newStatus, values });
      }
      _enqueueExposure(name, exposure, options) {
        if ((options === null || options === void 0 ? void 0 : options.disableExposureLog) === true) {
          this._logger.incrementNonExposureCount(name);
          return;
        }
        this._logger.enqueue(exposure);
      }
      _memoize(prefix, fn) {
        return (name, options) => {
          if (this._options.disableEvaluationMemoization) {
            return fn(name, options);
          }
          const memoKey = (0, MemoKey_1.createMemoKey)(prefix, name, options);
          if (!memoKey) {
            return fn(name, options);
          }
          if (!(memoKey in this._memoCache)) {
            if (Object.keys(this._memoCache).length >= MAX_MEMO_CACHE_SIZE) {
              this._memoCache = {};
            }
            this._memoCache[memoKey] = fn(name, options);
          }
          return this._memoCache[memoKey];
        };
      }
    };
    exports.StatsigClientBase = StatsigClientBase;
    function _assignGlobalInstance(sdkKey, client) {
      var _a;
      if ((0, SafeJs_1._isServerEnv)()) {
        return;
      }
      const statsigGlobal = (0, __StatsigGlobal_1._getStatsigGlobal)();
      const instances = (_a = statsigGlobal.instances) !== null && _a !== void 0 ? _a : {};
      const inst = client;
      if (instances[sdkKey] != null) {
        Log_1.Log.warn("Creating multiple Statsig clients with the same SDK key can lead to unexpected behavior. Multi-instance support requires different SDK keys.");
      }
      instances[sdkKey] = inst;
      if (!statsigGlobal.firstInstance) {
        statsigGlobal.firstInstance = inst;
      }
      statsigGlobal.instances = instances;
      __STATSIG__ = statsigGlobal;
    }
  }
});

// node_modules/@statsig/client-core/src/StatsigDataAdapter.js
var require_StatsigDataAdapter = __commonJS({
  "node_modules/@statsig/client-core/src/StatsigDataAdapter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DataAdapterCachePrefix = void 0;
    exports.DataAdapterCachePrefix = "statsig.cached";
  }
});

// node_modules/@statsig/client-core/src/StatsigPlugin.js
var require_StatsigPlugin = __commonJS({
  "node_modules/@statsig/client-core/src/StatsigPlugin.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@statsig/client-core/src/StatsigTypeFactories.js
var require_StatsigTypeFactories = __commonJS({
  "node_modules/@statsig/client-core/src/StatsigTypeFactories.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._makeTypedGet = exports._mergeOverride = exports._makeLayer = exports._makeExperiment = exports._makeDynamicConfig = exports._makeFeatureGate = void 0;
    var Log_1 = require_Log();
    var TypingUtils_1 = require_TypingUtils();
    function _makeEvaluation(name, details, evaluation, value) {
      var _a;
      return {
        name,
        details,
        ruleID: (_a = evaluation === null || evaluation === void 0 ? void 0 : evaluation.rule_id) !== null && _a !== void 0 ? _a : "",
        __evaluation: evaluation,
        value
      };
    }
    function _makeFeatureGate(name, details, evaluation) {
      var _a;
      return Object.assign(Object.assign({}, _makeEvaluation(name, details, evaluation, (evaluation === null || evaluation === void 0 ? void 0 : evaluation.value) === true)), { idType: (_a = evaluation === null || evaluation === void 0 ? void 0 : evaluation.id_type) !== null && _a !== void 0 ? _a : null });
    }
    exports._makeFeatureGate = _makeFeatureGate;
    function _makeDynamicConfig(name, details, evaluation) {
      var _a;
      const value = (_a = evaluation === null || evaluation === void 0 ? void 0 : evaluation.value) !== null && _a !== void 0 ? _a : {};
      return Object.assign(Object.assign({}, _makeEvaluation(name, details, evaluation, value)), { get: _makeTypedGet(name, evaluation === null || evaluation === void 0 ? void 0 : evaluation.value) });
    }
    exports._makeDynamicConfig = _makeDynamicConfig;
    function _makeExperiment(name, details, evaluation) {
      var _a;
      const result = _makeDynamicConfig(name, details, evaluation);
      return Object.assign(Object.assign({}, result), { groupName: (_a = evaluation === null || evaluation === void 0 ? void 0 : evaluation.group_name) !== null && _a !== void 0 ? _a : null });
    }
    exports._makeExperiment = _makeExperiment;
    function _makeLayer(name, details, evaluation, exposeFunc) {
      var _a, _b;
      return Object.assign(Object.assign({}, _makeEvaluation(name, details, evaluation, void 0)), { get: _makeTypedGet(name, evaluation === null || evaluation === void 0 ? void 0 : evaluation.value, exposeFunc), groupName: (_a = evaluation === null || evaluation === void 0 ? void 0 : evaluation.group_name) !== null && _a !== void 0 ? _a : null, __value: (_b = evaluation === null || evaluation === void 0 ? void 0 : evaluation.value) !== null && _b !== void 0 ? _b : {} });
    }
    exports._makeLayer = _makeLayer;
    function _mergeOverride(original, overridden, value, exposeFunc) {
      return Object.assign(Object.assign(Object.assign({}, original), overridden), { get: _makeTypedGet(original.name, value, exposeFunc) });
    }
    exports._mergeOverride = _mergeOverride;
    function _makeTypedGet(name, value, exposeFunc) {
      return (param, fallback) => {
        var _a;
        const found = (_a = value === null || value === void 0 ? void 0 : value[param]) !== null && _a !== void 0 ? _a : null;
        if (found == null) {
          return fallback !== null && fallback !== void 0 ? fallback : null;
        }
        if (fallback != null && !(0, TypingUtils_1._isTypeMatch)(found, fallback)) {
          Log_1.Log.warn(`Parameter type mismatch. '${name}.${param}' was found to be type '${typeof found}' but fallback/return type is '${typeof fallback}'. See https://docs.statsig.com/client/javascript-sdk/#typed-getters`);
          return fallback !== null && fallback !== void 0 ? fallback : null;
        }
        exposeFunc === null || exposeFunc === void 0 ? void 0 : exposeFunc(param);
        return found;
      };
    }
    exports._makeTypedGet = _makeTypedGet;
  }
});

// node_modules/@statsig/client-core/src/StatsigTypes.js
var require_StatsigTypes = __commonJS({
  "node_modules/@statsig/client-core/src/StatsigTypes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@statsig/client-core/src/StatsigUpdateDetails.js
var require_StatsigUpdateDetails = __commonJS({
  "node_modules/@statsig/client-core/src/StatsigUpdateDetails.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UPDATE_DETAIL_ERROR_MESSAGES = exports.createUpdateDetails = void 0;
    var createUpdateDetails = (success, source, initDuration, error, sourceUrl, warnings) => {
      return {
        duration: initDuration,
        source,
        success,
        error,
        sourceUrl,
        warnings
      };
    };
    exports.createUpdateDetails = createUpdateDetails;
    exports.UPDATE_DETAIL_ERROR_MESSAGES = {
      NO_NETWORK_DATA: "No data was returned from the network. This may be due to a network timeout if a timeout value was specified in the options or ad blocker error."
    };
  }
});

// node_modules/@statsig/client-core/src/index.js
var require_src = __commonJS({
  "node_modules/@statsig/client-core/src/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Storage = exports.Log = exports.EventLogger = exports.Diagnostics = void 0;
    require_StatsigGlobal();
    var __StatsigGlobal_1 = require_StatsigGlobal();
    var Diagnostics_1 = require_Diagnostics();
    Object.defineProperty(exports, "Diagnostics", { enumerable: true, get: function() {
      return Diagnostics_1.Diagnostics;
    } });
    var EventLogger_1 = require_EventLogger();
    Object.defineProperty(exports, "EventLogger", { enumerable: true, get: function() {
      return EventLogger_1.EventLogger;
    } });
    var Log_1 = require_Log();
    Object.defineProperty(exports, "Log", { enumerable: true, get: function() {
      return Log_1.Log;
    } });
    var StatsigMetadata_1 = require_StatsigMetadata();
    var StorageProvider_1 = require_StorageProvider();
    Object.defineProperty(exports, "Storage", { enumerable: true, get: function() {
      return StorageProvider_1.Storage;
    } });
    __exportStar(require_StatsigGlobal(), exports);
    __exportStar(require_CacheKey(), exports);
    __exportStar(require_ClientInterfaces(), exports);
    __exportStar(require_DataAdapterCore(), exports);
    __exportStar(require_Diagnostics(), exports);
    __exportStar(require_DownloadConfigSpecsResponse(), exports);
    __exportStar(require_ErrorBoundary(), exports);
    __exportStar(require_EvaluationOptions(), exports);
    __exportStar(require_EvaluationTypes(), exports);
    __exportStar(require_Hashing(), exports);
    __exportStar(require_InitializeResponse(), exports);
    __exportStar(require_Log(), exports);
    __exportStar(require_MemoKey(), exports);
    __exportStar(require_NetworkConfig(), exports);
    __exportStar(require_NetworkCore(), exports);
    __exportStar(require_OverrideAdapter(), exports);
    __exportStar(require_ParamStoreTypes(), exports);
    __exportStar(require_SafeJs(), exports);
    __exportStar(require_SDKType(), exports);
    __exportStar(require_SessionID(), exports);
    __exportStar(require_StableID(), exports);
    __exportStar(require_StatsigClientBase(), exports);
    __exportStar(require_StatsigClientEventEmitter(), exports);
    __exportStar(require_StatsigDataAdapter(), exports);
    __exportStar(require_StatsigEvent(), exports);
    __exportStar(require_StatsigMetadata(), exports);
    __exportStar(require_StatsigOptionsCommon(), exports);
    __exportStar(require_StatsigPlugin(), exports);
    __exportStar(require_StatsigTypeFactories(), exports);
    __exportStar(require_StatsigTypes(), exports);
    __exportStar(require_StatsigUser(), exports);
    __exportStar(require_StorageProvider(), exports);
    __exportStar(require_TypedJsonParse(), exports);
    __exportStar(require_TypingUtils(), exports);
    __exportStar(require_UrlConfiguration(), exports);
    __exportStar(require_UUID(), exports);
    __exportStar(require_VisibilityObserving(), exports);
    __exportStar(require_StatsigUpdateDetails(), exports);
    __exportStar(require_SDKFlags(), exports);
    Object.assign((0, __StatsigGlobal_1._getStatsigGlobal)(), { Log: Log_1.Log, SDK_VERSION: StatsigMetadata_1.SDK_VERSION });
  }
});

export {
  require_src
};
//# sourceMappingURL=chunk-SZ6QUZOK.js.map
