import {
  require_jsx_runtime
} from "./chunk-VZBRM2AZ.js";
import {
  require_src
} from "./chunk-SZ6QUZOK.js";
import {
  require_react
} from "./chunk-LXGCQ6UQ.js";
import {
  __commonJS
} from "./chunk-ROME4SDB.js";

// node_modules/@statsig/react-bindings/src/NoopEvaluationsClient.js
var require_NoopEvaluationsClient = __commonJS({
  "node_modules/@statsig/react-bindings/src/NoopEvaluationsClient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isNoopClient = exports.NoopEvaluationsClient = void 0;
    var client_core_1 = require_src();
    var noopInitializeDetails = {
      success: false,
      error: Error("NoClient"),
      duration: 0,
      source: "Uninitialized",
      sourceUrl: null
    };
    var _noop = () => {
    };
    var _noopWithInitializeDetails = () => noopInitializeDetails;
    var _noopAsync = () => Promise.resolve();
    var _noopAsyncWithInitializeDetails = () => Promise.resolve(noopInitializeDetails);
    var NOOP_DETAILS = { reason: "Error:NoClient" };
    var _defaultEvaluation = (type) => {
      return (...args) => {
        const name = typeof args[0] === "string" ? args[0] : args[1];
        switch (type) {
          case "gate":
            return (0, client_core_1._makeFeatureGate)(name, NOOP_DETAILS, null);
          case "config":
            return (0, client_core_1._makeDynamicConfig)(name, NOOP_DETAILS, null);
          case "layer":
            return (0, client_core_1._makeLayer)(name, NOOP_DETAILS, null);
          case "param_store":
            return { name };
        }
      };
    };
    var _noopDataAdapter = {
      attach: _noop,
      getDataSync: () => null,
      getDataAsync: () => Promise.resolve(null),
      setData: _noop,
      setDataLegacy: _noop,
      prefetchData: _noopAsync
    };
    var context = {
      sdkKey: "",
      options: {},
      values: null,
      user: { userID: "" },
      errorBoundary: {},
      session: {
        data: { sessionID: "", startTime: 0, lastUpdate: 0 },
        sdkKey: ""
      },
      stableID: "",
      storageProvider: client_core_1.Storage
    };
    var _client = {
      isNoop: true,
      loadingStatus: "Uninitialized",
      initializeSync: _noopWithInitializeDetails,
      initializeAsync: _noopAsyncWithInitializeDetails,
      shutdown: _noopAsync,
      flush: _noopAsync,
      updateRuntimeOptions: _noop,
      updateUserSync: _noopWithInitializeDetails,
      updateUserAsync: _noopAsyncWithInitializeDetails,
      getContext: () => Object.assign({}, context),
      checkGate: () => false,
      getFeatureGate: _defaultEvaluation("gate"),
      getDynamicConfig: _defaultEvaluation("config"),
      getExperiment: _defaultEvaluation("config"),
      getLayer: _defaultEvaluation("layer"),
      getParameterStore: _defaultEvaluation("param_store"),
      logEvent: _noop,
      on: _noop,
      off: _noop,
      $on: _noop,
      $emt: _noop,
      dataAdapter: _noopDataAdapter
    };
    exports.NoopEvaluationsClient = _client;
    function isNoopClient(client) {
      return "isNoop" in client;
    }
    exports.isNoopClient = isNoopClient;
  }
});

// node_modules/@statsig/react-bindings/src/StatsigContext.js
var require_StatsigContext = __commonJS({
  "node_modules/@statsig/react-bindings/src/StatsigContext.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var react_1 = require_react();
    var NoopEvaluationsClient_1 = require_NoopEvaluationsClient();
    exports.default = (0, react_1.createContext)({
      renderVersion: 0,
      client: NoopEvaluationsClient_1.NoopEvaluationsClient,
      isLoading: true
    });
  }
});

// node_modules/@statsig/js-client/src/EvaluationStore.js
var require_EvaluationStore = __commonJS({
  "node_modules/@statsig/js-client/src/EvaluationStore.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var client_core_1 = require_src();
    var EvaluationStore = class {
      constructor(_sdkKey) {
        this._sdkKey = _sdkKey;
        this._rawValues = null;
        this._values = null;
        this._source = "Uninitialized";
        this._lcut = 0;
        this._receivedAt = 0;
        this._bootstrapMetadata = null;
        this._warnings = /* @__PURE__ */ new Set();
      }
      reset() {
        this._values = null;
        this._rawValues = null;
        this._source = "Loading";
        this._lcut = 0;
        this._receivedAt = 0;
        this._bootstrapMetadata = null;
      }
      finalize() {
        if (this._values) {
          return;
        }
        this._source = "NoValues";
      }
      getValues() {
        return this._rawValues ? (0, client_core_1._typedJsonParse)(this._rawValues, "has_updates", "EvaluationStoreValues") : null;
      }
      setValues(result, user) {
        var _a;
        if (!result) {
          return false;
        }
        const values = (0, client_core_1._typedJsonParse)(result.data, "has_updates", "EvaluationResponse");
        if (values == null) {
          return false;
        }
        this._source = result.source;
        if ((values === null || values === void 0 ? void 0 : values.has_updates) !== true) {
          return true;
        }
        this._rawValues = result.data;
        this._lcut = values.time;
        this._receivedAt = result.receivedAt;
        this._values = values;
        this._bootstrapMetadata = this._extractBootstrapMetadata(result.source, values);
        if (result.source && values.user) {
          this._setWarningState(user, values);
        }
        client_core_1.SDKFlags.setFlags(this._sdkKey, (_a = values.sdk_flags) !== null && _a !== void 0 ? _a : {});
        return true;
      }
      getWarnings() {
        if (this._warnings.size === 0) {
          return void 0;
        }
        return Array.from(this._warnings);
      }
      getGate(name) {
        var _a;
        return this._getDetailedStoreResult((_a = this._values) === null || _a === void 0 ? void 0 : _a.feature_gates, name);
      }
      getConfig(name) {
        var _a;
        return this._getDetailedStoreResult((_a = this._values) === null || _a === void 0 ? void 0 : _a.dynamic_configs, name);
      }
      getLayer(name) {
        var _a;
        return this._getDetailedStoreResult((_a = this._values) === null || _a === void 0 ? void 0 : _a.layer_configs, name);
      }
      getParamStore(name) {
        var _a;
        return this._getDetailedStoreResult((_a = this._values) === null || _a === void 0 ? void 0 : _a.param_stores, name);
      }
      getSource() {
        return this._source;
      }
      getExposureMapping() {
        var _a;
        return (_a = this._values) === null || _a === void 0 ? void 0 : _a.exposures;
      }
      _extractBootstrapMetadata(source, values) {
        if (source !== "Bootstrap") {
          return null;
        }
        const bootstrapMetadata = {};
        if (values.user) {
          bootstrapMetadata.user = values.user;
        }
        if (values.sdkInfo) {
          bootstrapMetadata.generatorSDKInfo = values.sdkInfo;
        }
        bootstrapMetadata.lcut = values.time;
        return bootstrapMetadata;
      }
      _getDetailedStoreResult(lookup, name) {
        let result = null;
        if (lookup) {
          result = lookup[name] ? lookup[name] : lookup[(0, client_core_1._DJB2)(name)];
        }
        return {
          result,
          details: this._getDetails(result == null)
        };
      }
      _setWarningState(user, values) {
        var _a, _b;
        const stableID = client_core_1.StableID.get(this._sdkKey);
        if (((_a = user.customIDs) === null || _a === void 0 ? void 0 : _a.stableID) !== stableID && // don't throw if they're both undefined
        (((_b = user.customIDs) === null || _b === void 0 ? void 0 : _b.stableID) || stableID)) {
          this._warnings.add("StableIDMismatch");
          return;
        }
        if ("user" in values) {
          const bootstrapUser = values["user"];
          if ((0, client_core_1._getFullUserHash)(user) !== (0, client_core_1._getFullUserHash)(bootstrapUser)) {
            this._warnings.add("PartialUserMatch");
          }
        }
      }
      getCurrentSourceDetails() {
        if (this._source === "Uninitialized" || this._source === "NoValues") {
          return { reason: this._source };
        }
        const sourceDetails = {
          reason: this._source,
          lcut: this._lcut,
          receivedAt: this._receivedAt
        };
        if (this._warnings.size > 0) {
          sourceDetails.warnings = Array.from(this._warnings);
        }
        return sourceDetails;
      }
      _getDetails(isUnrecognized) {
        var _a, _b;
        const sourceDetails = this.getCurrentSourceDetails();
        let reason = sourceDetails.reason;
        const warnings = (_a = sourceDetails.warnings) !== null && _a !== void 0 ? _a : [];
        if (this._source === "Bootstrap" && warnings.length > 0) {
          reason = reason + warnings[0];
        }
        if (reason !== "Uninitialized" && reason !== "NoValues") {
          const subreason = isUnrecognized ? "Unrecognized" : "Recognized";
          reason = `${reason}:${subreason}`;
        }
        const bootstrapMetadata = this._source === "Bootstrap" ? (_b = this._bootstrapMetadata) !== null && _b !== void 0 ? _b : void 0 : void 0;
        if (bootstrapMetadata) {
          sourceDetails.bootstrapMetadata = bootstrapMetadata;
        }
        return Object.assign(Object.assign({}, sourceDetails), { reason });
      }
    };
    exports.default = EvaluationStore;
  }
});

// node_modules/@statsig/js-client/src/EvaluationResponseDeltas.js
var require_EvaluationResponseDeltas = __commonJS({
  "node_modules/@statsig/js-client/src/EvaluationResponseDeltas.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._resolveDeltasResponse = void 0;
    var client_core_1 = require_src();
    var MAX_DELTAS_SORT_DEPTH = 2;
    function _resolveDeltasResponse(cache, deltasString) {
      const deltas = (0, client_core_1._typedJsonParse)(deltasString, "checksum", "DeltasEvaluationResponse");
      if (!deltas) {
        return {
          hadBadDeltaChecksum: true
        };
      }
      const merged = _mergeDeltasIntoCache(cache, deltas);
      const resolved = _handleDeletedEntries(merged);
      const actualChecksum = (0, client_core_1._DJB2Object)({
        feature_gates: resolved.feature_gates,
        dynamic_configs: resolved.dynamic_configs,
        layer_configs: resolved.layer_configs
      }, MAX_DELTAS_SORT_DEPTH);
      const isMatch = actualChecksum === deltas.checksumV2;
      if (!isMatch) {
        return {
          hadBadDeltaChecksum: true,
          badChecksum: actualChecksum,
          badMergedConfigs: resolved,
          badFullResponse: deltas.deltas_full_response
        };
      }
      return JSON.stringify(resolved);
    }
    exports._resolveDeltasResponse = _resolveDeltasResponse;
    function _mergeDeltasIntoCache(cache, deltas) {
      return Object.assign(Object.assign(Object.assign({}, cache), deltas), { feature_gates: Object.assign(Object.assign({}, cache.feature_gates), deltas.feature_gates), layer_configs: Object.assign(Object.assign({}, cache.layer_configs), deltas.layer_configs), dynamic_configs: Object.assign(Object.assign({}, cache.dynamic_configs), deltas.dynamic_configs) });
    }
    function _handleDeletedEntries(deltas) {
      const result = deltas;
      _deleteEntriesInRecord(deltas.deleted_gates, result.feature_gates);
      delete result.deleted_gates;
      _deleteEntriesInRecord(deltas.deleted_configs, result.dynamic_configs);
      delete result.deleted_configs;
      _deleteEntriesInRecord(deltas.deleted_layers, result.layer_configs);
      delete result.deleted_layers;
      return result;
    }
    function _deleteEntriesInRecord(keys, values) {
      keys === null || keys === void 0 ? void 0 : keys.forEach((key) => {
        delete values[key];
      });
    }
  }
});

// node_modules/@statsig/js-client/src/Network.js
var require_Network = __commonJS({
  "node_modules/@statsig/js-client/src/Network.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var client_core_1 = require_src();
    var EvaluationResponseDeltas_1 = require_EvaluationResponseDeltas();
    var StatsigNetwork = class extends client_core_1.NetworkCore {
      constructor(options, emitter) {
        super(options, emitter);
        const config = options === null || options === void 0 ? void 0 : options.networkConfig;
        this._option = options;
        this._initializeUrlConfig = new client_core_1.UrlConfiguration(client_core_1.Endpoint._initialize, config === null || config === void 0 ? void 0 : config.initializeUrl, config === null || config === void 0 ? void 0 : config.api, config === null || config === void 0 ? void 0 : config.initializeFallbackUrls);
      }
      fetchEvaluations(sdkKey, current, priority, user, isCacheValidFor204) {
        var _a, _b, _c, _d, _e, _f;
        return __awaiter(this, void 0, void 0, function* () {
          const cache = current ? (0, client_core_1._typedJsonParse)(current, "has_updates", "InitializeResponse") : null;
          let data = {
            user,
            hash: (_c = (_b = (_a = this._option) === null || _a === void 0 ? void 0 : _a.networkConfig) === null || _b === void 0 ? void 0 : _b.initializeHashAlgorithm) !== null && _c !== void 0 ? _c : "djb2",
            deltasResponseRequested: false,
            full_checksum: null
          };
          if (cache === null || cache === void 0 ? void 0 : cache.has_updates) {
            const hasHashChanged = (cache === null || cache === void 0 ? void 0 : cache.hash_used) !== ((_f = (_e = (_d = this._option) === null || _d === void 0 ? void 0 : _d.networkConfig) === null || _e === void 0 ? void 0 : _e.initializeHashAlgorithm) !== null && _f !== void 0 ? _f : "djb2");
            data = Object.assign(Object.assign({}, data), { sinceTime: isCacheValidFor204 && !hasHashChanged ? cache.time : 0, previousDerivedFields: "derived_fields" in cache && isCacheValidFor204 ? cache.derived_fields : {}, deltasResponseRequested: true, full_checksum: cache.full_checksum, partialUserMatchSinceTime: !hasHashChanged ? cache.time : 0 });
          }
          return this._fetchEvaluations(sdkKey, cache, data, priority);
        });
      }
      _fetchEvaluations(sdkKey, cache, data, priority) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
          const response = yield this.post({
            sdkKey,
            urlConfig: this._initializeUrlConfig,
            data,
            retries: 2,
            isStatsigEncodable: true,
            priority
          });
          if ((response === null || response === void 0 ? void 0 : response.code) === 204) {
            return '{"has_updates": false}';
          }
          if ((response === null || response === void 0 ? void 0 : response.code) !== 200) {
            return (_a = response === null || response === void 0 ? void 0 : response.body) !== null && _a !== void 0 ? _a : null;
          }
          if ((cache === null || cache === void 0 ? void 0 : cache.has_updates) !== true || ((_b = response.body) === null || _b === void 0 ? void 0 : _b.includes('"is_delta":true')) !== true || data.deltasResponseRequested !== true) {
            return response.body;
          }
          const result = (0, EvaluationResponseDeltas_1._resolveDeltasResponse)(cache, response.body);
          if (typeof result === "string") {
            return result;
          }
          return this._fetchEvaluations(sdkKey, cache, Object.assign(Object.assign(Object.assign({}, data), result), { deltasResponseRequested: false }), priority);
        });
      }
    };
    exports.default = StatsigNetwork;
  }
});

// node_modules/@statsig/js-client/src/ParamStoreGetterFactory.js
var require_ParamStoreGetterFactory = __commonJS({
  "node_modules/@statsig/js-client/src/ParamStoreGetterFactory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._makeParamStoreGetter = void 0;
    var client_core_1 = require_src();
    var NO_EXPOSURE_OPT = {
      disableExposureLog: true
    };
    function _shouldLogExposure(options) {
      return options == null || options.disableExposureLog === false;
    }
    function _shouldReturnFallback(value, fallback) {
      return fallback != null && !(0, client_core_1._isTypeMatch)(value, fallback);
    }
    function _getMappedStaticValue(param, _options) {
      return param.value;
    }
    function _getMappedGateValue(client, param, options) {
      const gate = client.getFeatureGate(param.gate_name, _shouldLogExposure(options) ? void 0 : NO_EXPOSURE_OPT);
      if (gate.value) {
        return param.pass_value;
      }
      return param.fail_value;
    }
    function _getMappedDynamicConfigValue(client, param, fallback, options) {
      const config = client.getDynamicConfig(param.config_name, _shouldLogExposure(options) ? void 0 : NO_EXPOSURE_OPT);
      const value = config.get(param.param_name);
      if (_shouldReturnFallback(value, fallback)) {
        return fallback;
      }
      return value;
    }
    function _getMappedExperimentValue(client, param, fallback, options) {
      const experiment = client.getExperiment(param.experiment_name, _shouldLogExposure(options) ? void 0 : NO_EXPOSURE_OPT);
      const value = experiment.get(param.param_name);
      if (_shouldReturnFallback(value, fallback)) {
        return fallback;
      }
      return value;
    }
    function _getMappedLayerValue(client, param, fallback, options) {
      const layer = client.getLayer(param.layer_name, _shouldLogExposure(options) ? void 0 : NO_EXPOSURE_OPT);
      const value = layer.get(param.param_name);
      if (_shouldReturnFallback(value, fallback)) {
        return fallback;
      }
      return value;
    }
    function _makeParamStoreGetter(client, config, options) {
      return (paramName, fallback) => {
        if (config == null) {
          return fallback;
        }
        const param = config[paramName];
        if (param == null || fallback != null && (0, client_core_1._typeOf)(fallback) !== param.param_type) {
          return fallback;
        }
        switch (param.ref_type) {
          case "static":
            return _getMappedStaticValue(param, options);
          case "gate":
            return _getMappedGateValue(client, param, options);
          case "dynamic_config":
            return _getMappedDynamicConfigValue(client, param, fallback, options);
          case "experiment":
            return _getMappedExperimentValue(client, param, fallback, options);
          case "layer":
            return _getMappedLayerValue(client, param, fallback, options);
          default:
            return fallback;
        }
      };
    }
    exports._makeParamStoreGetter = _makeParamStoreGetter;
  }
});

// node_modules/@statsig/js-client/src/StatsigEvaluationsDataAdapter.js
var require_StatsigEvaluationsDataAdapter = __commonJS({
  "node_modules/@statsig/js-client/src/StatsigEvaluationsDataAdapter.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StatsigEvaluationsDataAdapter = void 0;
    var client_core_1 = require_src();
    var Network_1 = require_Network();
    var StatsigEvaluationsDataAdapter = class extends client_core_1.DataAdapterCore {
      constructor() {
        super("EvaluationsDataAdapter", "evaluations");
        this._network = null;
        this._options = null;
      }
      attach(sdkKey, options, network) {
        super.attach(sdkKey, options, network);
        if (network !== null && network instanceof Network_1.default) {
          this._network = network;
        } else {
          this._network = new Network_1.default(options !== null && options !== void 0 ? options : {});
        }
      }
      getDataAsync(current, user, options) {
        return this._getDataAsyncImpl(current, (0, client_core_1._normalizeUser)(user, this._options), options);
      }
      prefetchData(user, options) {
        return this._prefetchDataImpl(user, options);
      }
      setData(data) {
        const values = (0, client_core_1._typedJsonParse)(data, "has_updates", "data");
        if (values && "user" in values) {
          super.setData(data, values.user);
        } else {
          client_core_1.Log.error("StatsigUser not found. You may be using an older server SDK version. Please upgrade your SDK or use setDataLegacy.");
        }
      }
      setDataLegacy(data, user) {
        super.setData(data, user);
      }
      _fetchFromNetwork(current, user, options, isCacheValidFor204) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          const result = yield (_a = this._network) === null || _a === void 0 ? void 0 : _a.fetchEvaluations(this._getSdkKey(), current, options === null || options === void 0 ? void 0 : options.priority, user, isCacheValidFor204);
          return result !== null && result !== void 0 ? result : null;
        });
      }
      _getCacheKey(user) {
        var _a;
        const key = (0, client_core_1._getStorageKey)(this._getSdkKey(), user, (_a = this._options) === null || _a === void 0 ? void 0 : _a.customUserCacheKeyFunc);
        return `${client_core_1.DataAdapterCachePrefix}.${this._cacheSuffix}.${key}`;
      }
      _isCachedResultValidFor204(result, user) {
        return result.fullUserHash != null && result.fullUserHash === (0, client_core_1._getFullUserHash)(user);
      }
    };
    exports.StatsigEvaluationsDataAdapter = StatsigEvaluationsDataAdapter;
  }
});

// node_modules/@statsig/js-client/src/StatsigClient.js
var require_StatsigClient = __commonJS({
  "node_modules/@statsig/js-client/src/StatsigClient.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var client_core_1 = require_src();
    var EvaluationStore_1 = require_EvaluationStore();
    var Network_1 = require_Network();
    var ParamStoreGetterFactory_1 = require_ParamStoreGetterFactory();
    var StatsigEvaluationsDataAdapter_1 = require_StatsigEvaluationsDataAdapter();
    var StatsigClient = class _StatsigClient extends client_core_1.StatsigClientBase {
      /**
       * Retrieves an instance of the StatsigClient based on the provided SDK key.
       *  If no SDK key is provided, the method returns the most recently created instance of the StatsigClient.
       *  The method ensures that each unique SDK key corresponds to a single instance of StatsigClient, effectively implementing a singleton pattern for each key.
       *
       * @param {string} [sdkKey] - Optional. The SDK key used to identify a specific instance of the StatsigClient. If omitted, the method returns the last created instance.
       * @returns {StatsigClient|undefined} Returns the StatsigClient instance associated with the given SDK key, or undefined if no instance is associated with the key or if no key is provided and no instances exist.
       */
      static instance(sdkKey) {
        const instance = (0, client_core_1._getStatsigGlobal)().instance(sdkKey);
        if (instance instanceof _StatsigClient) {
          return instance;
        }
        client_core_1.Log.warn((0, client_core_1._isServerEnv)() ? "StatsigClient.instance is not supported in server environments" : "Unable to find StatsigClient instance");
        return new _StatsigClient(sdkKey !== null && sdkKey !== void 0 ? sdkKey : "", {});
      }
      /**
       * StatsigClient constructor
       *
       * @param {string} sdkKey A Statsig client SDK key. eg "client-xyz123..."
       * @param {StatsigUser} user StatsigUser object containing various attributes related to a user.
       * @param {StatsigOptions | null} options StatsigOptions, used to customize the behavior of the SDK.
       */
      constructor(sdkKey, user, options = null) {
        var _a, _b;
        client_core_1.SDKType._setClientType(sdkKey, "javascript-client");
        const network = new Network_1.default(options, (e) => {
          this.$emt(e);
        });
        super(sdkKey, (_a = options === null || options === void 0 ? void 0 : options.dataAdapter) !== null && _a !== void 0 ? _a : new StatsigEvaluationsDataAdapter_1.StatsigEvaluationsDataAdapter(), network, options);
        this.getFeatureGate = this._memoize(client_core_1.MemoPrefix._gate, this._getFeatureGateImpl.bind(this));
        this.getDynamicConfig = this._memoize(client_core_1.MemoPrefix._dynamicConfig, this._getDynamicConfigImpl.bind(this));
        this.getExperiment = this._memoize(client_core_1.MemoPrefix._experiment, this._getExperimentImpl.bind(this));
        this.getLayer = this._memoize(client_core_1.MemoPrefix._layer, this._getLayerImpl.bind(this));
        this.getParameterStore = this._memoize(client_core_1.MemoPrefix._paramStore, this._getParameterStoreImpl.bind(this));
        this._store = new EvaluationStore_1.default(sdkKey);
        this._network = network;
        this._user = this._configureUser(user, options);
        const plugins = (_b = options === null || options === void 0 ? void 0 : options.plugins) !== null && _b !== void 0 ? _b : [];
        for (const plugin of plugins) {
          plugin.bind(this);
        }
      }
      /**
       * Initializes the StatsigClient using cached values. This method sets up the client synchronously by utilizing previously cached values.
       * After initialization, cache values are updated in the background for future use, either in subsequent sessions or when `updateUser` is called.
       * This is useful for quickly starting with the last-known-good configurations while refreshing data to keep settings up-to-date.
       *
       * @see {@link initializeAsync} for the asynchronous version of this method.
       */
      initializeSync(options) {
        var _a;
        if (this.loadingStatus !== "Uninitialized") {
          return (0, client_core_1.createUpdateDetails)(true, this._store.getSource(), -1, null, null, ["MultipleInitializations", ...(_a = this._store.getWarnings()) !== null && _a !== void 0 ? _a : []]);
        }
        this._logger.start();
        return this.updateUserSync(this._user, options);
      }
      /**
       * Initializes the StatsigClient asynchronously by first using cached values and then updating to the latest values from the network.
       * Once the network values are fetched, they replace the existing cached values. If this method's promise is not awaited,
       * there might be a transition from cached to network values during the session, which can affect consistency.
       * This method is useful when it's acceptable to begin with potentially stale data and switch to the latest configuration as it becomes available.
       *
       * @param {AsyncUpdateOptions} [options] - Optional. Additional options to customize the method call.
       * @returns {Promise<void>} A promise that resolves once the client is fully initialized with the latest values from the network or a timeout (if set) is hit.
       * @see {@link initializeSync} for the synchronous version of this method.
       */
      initializeAsync(options) {
        return __awaiter(this, void 0, void 0, function* () {
          if (this._initializePromise) {
            return this._initializePromise;
          }
          this._initializePromise = this._initializeAsyncImpl(options);
          return this._initializePromise;
        });
      }
      /**
       * Synchronously updates the user in the Statsig client and switches the internal state to use cached values for the newly specified user.
       * After the initial switch to cached values, this method updates these values in the background, preparing them for future sessions or subsequent calls to updateUser.
       * This method ensures the client is quickly ready with available data.
       *
       * @param {StatsigUser} user - The new StatsigUser for which the client should update its internal state.
       * @see {@link updateUserAsync} for the asynchronous version of this method.
       */
      updateUserSync(user, options) {
        const startTime = performance.now();
        try {
          return this._updateUserSyncImpl(user, options, startTime);
        } catch (e) {
          const err = e instanceof Error ? e : new Error(String(e));
          return this._createErrorUpdateDetails(err, startTime);
        }
      }
      _updateUserSyncImpl(user, options, startTime) {
        var _a;
        const warnings = [...(_a = this._store.getWarnings()) !== null && _a !== void 0 ? _a : []];
        this._resetForUser(user);
        const result = this.dataAdapter.getDataSync(this._user);
        if (result == null) {
          warnings.push("NoCachedValues");
        }
        this._store.setValues(result, this._user);
        this._finalizeUpdate(result);
        const disable = options === null || options === void 0 ? void 0 : options.disableBackgroundCacheRefresh;
        if (disable === true || disable == null && (result === null || result === void 0 ? void 0 : result.source) === "Bootstrap") {
          return (0, client_core_1.createUpdateDetails)(true, this._store.getSource(), performance.now() - startTime, this._errorBoundary.getLastSeenErrorAndReset(), this._network.getLastUsedInitUrlAndReset(), warnings);
        }
        this._runPostUpdate(result !== null && result !== void 0 ? result : null, this._user);
        return (0, client_core_1.createUpdateDetails)(true, this._store.getSource(), performance.now() - startTime, this._errorBoundary.getLastSeenErrorAndReset(), this._network.getLastUsedInitUrlAndReset(), warnings);
      }
      /**
       * Asynchronously updates the user in the Statsig client by initially using cached values and then fetching the latest values from the network.
       * When the latest values are fetched, they replace the cached values. If the promise returned by this method is not awaited,
       * the client's state may shift from cached to updated network values during the session, potentially affecting consistency.
       * This method is best used in scenarios where up-to-date configuration is critical and initial delays are acceptable.
       *
       * @param {StatsigUser} user - The new StatsigUser for which the client should update its internal state.
       * @param {AsyncUpdateOptions} [options] - Optional. Additional options to customize the method call.
       * @returns {Promise<void>} A promise that resolves once the client is fully updated with the latest values from the network or a timeout (if set) is hit.
       * @see {@link updateUserSync} for the synchronous version of this method.
       */
      updateUserAsync(user, options) {
        return __awaiter(this, void 0, void 0, function* () {
          const startTime = performance.now();
          try {
            return yield this._updateUserAsyncImpl(user, options);
          } catch (e) {
            const err = e instanceof Error ? e : new Error(String(e));
            return this._createErrorUpdateDetails(err, startTime);
          }
        });
      }
      _updateUserAsyncImpl(user, options) {
        return __awaiter(this, void 0, void 0, function* () {
          this._resetForUser(user);
          const initiator = this._user;
          client_core_1.Diagnostics._markInitOverallStart(this._sdkKey);
          let result = this.dataAdapter.getDataSync(initiator);
          this._store.setValues(result, this._user);
          this._setStatus("Loading", result);
          result = yield this.dataAdapter.getDataAsync(result, initiator, options);
          if (initiator !== this._user) {
            return (0, client_core_1.createUpdateDetails)(false, this._store.getSource(), -1, new Error("User changed during update"), this._network.getLastUsedInitUrlAndReset());
          }
          let isUsingNetworkValues = false;
          if (result != null) {
            client_core_1.Diagnostics._markInitProcessStart(this._sdkKey);
            isUsingNetworkValues = this._store.setValues(result, this._user);
            client_core_1.Diagnostics._markInitProcessEnd(this._sdkKey, {
              success: isUsingNetworkValues
            });
          }
          this._finalizeUpdate(result);
          if (!isUsingNetworkValues) {
            this._errorBoundary.attachErrorIfNoneExists(client_core_1.UPDATE_DETAIL_ERROR_MESSAGES.NO_NETWORK_DATA);
            this.$emt({ name: "initialization_failure" });
          }
          client_core_1.Diagnostics._markInitOverallEnd(this._sdkKey, isUsingNetworkValues, this._store.getCurrentSourceDetails());
          const initDuration = client_core_1.Diagnostics._enqueueDiagnosticsEvent(this._user, this._logger, this._sdkKey, this._options);
          return (0, client_core_1.createUpdateDetails)(isUsingNetworkValues, this._store.getSource(), initDuration, this._errorBoundary.getLastSeenErrorAndReset(), this._network.getLastUsedInitUrlAndReset(), this._store.getWarnings());
        });
      }
      /**
       * Retrieves a synchronous context containing data currently being used by the SDK. Represented as a {@link PrecomputedEvaluationsContext} object.
       *
       * @returns {PrecomputedEvaluationsContext} The current synchronous context for the this StatsigClient instance.
       */
      getContext() {
        return {
          sdkKey: this._sdkKey,
          options: this._options,
          values: this._store.getValues(),
          user: JSON.parse(JSON.stringify(this._user)),
          errorBoundary: this._errorBoundary,
          session: client_core_1.StatsigSession.get(this._sdkKey),
          stableID: client_core_1.StableID.get(this._sdkKey)
        };
      }
      /**
       * Retrieves the value of a feature gate for the current user, represented as a simple boolean.
       *
       * @param {string} name - The name of the feature gate to retrieve.
       * @param {FeatureGateEvaluationOptions} [options] - Optional. Additional options to customize the method call.
       * @returns {boolean} - The boolean value representing the gate's current evaluation results for the user.
       */
      checkGate(name, options) {
        return this.getFeatureGate(name, options).value;
      }
      /**
       * Logs an event to the internal logging system. This function allows logging by either passing a fully formed event object or by specifying the event name with optional value and metadata.
       *
       * @param {StatsigEvent|string} eventOrName - The event object conforming to the StatsigEvent interface, or the name of the event as a string.
       * @param {string|number} value - Optional. The value associated with the event, which can be a string or a number. This parameter is ignored if the first parameter is a StatsigEvent object.
       * @param {Record<string, string>} metadata - Optional. A key-value record containing metadata about the event. This is also ignored if the first parameter is an event object.
       */
      logEvent(eventOrName, value, metadata) {
        const event = typeof eventOrName === "string" ? {
          eventName: eventOrName,
          value,
          metadata
        } : eventOrName;
        this.$emt({
          name: "log_event_called",
          event
        });
        this._logger.enqueue(Object.assign(Object.assign({}, event), { user: this._user, time: Date.now() }));
      }
      _primeReadyRipcord() {
        this.$on("error", () => {
          this.loadingStatus === "Loading" && this._finalizeUpdate(null);
        });
      }
      _initializeAsyncImpl(options) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!client_core_1.Storage.isReady()) {
            yield client_core_1.Storage.isReadyResolver();
          }
          this._logger.start();
          return this.updateUserAsync(this._user, options);
        });
      }
      _createErrorUpdateDetails(error, startTime) {
        var _a;
        return (0, client_core_1.createUpdateDetails)(false, this._store.getSource(), performance.now() - startTime, error, null, [...(_a = this._store.getWarnings()) !== null && _a !== void 0 ? _a : []]);
      }
      _finalizeUpdate(values) {
        this._store.finalize();
        this._setStatus("Ready", values);
      }
      _runPostUpdate(current, user) {
        this.dataAdapter.getDataAsync(current, user, { priority: "low" }).catch((err) => {
          client_core_1.Log.error("An error occurred after update.", err);
        });
      }
      _resetForUser(user) {
        this._logger.reset();
        this._store.reset();
        this._user = this._configureUser(user, this._options);
      }
      _configureUser(originalUser, options) {
        var _a;
        const user = (0, client_core_1._normalizeUser)(originalUser, options);
        const stableIdOverride = (_a = user.customIDs) === null || _a === void 0 ? void 0 : _a.stableID;
        if (stableIdOverride) {
          client_core_1.StableID.setOverride(stableIdOverride, this._sdkKey);
        }
        return user;
      }
      _getFeatureGateImpl(name, options) {
        var _a, _b;
        const { result: evaluation, details } = this._store.getGate(name);
        const gate = (0, client_core_1._makeFeatureGate)(name, details, evaluation);
        const overridden = (_b = (_a = this.overrideAdapter) === null || _a === void 0 ? void 0 : _a.getGateOverride) === null || _b === void 0 ? void 0 : _b.call(_a, gate, this._user, options);
        const result = overridden !== null && overridden !== void 0 ? overridden : gate;
        this._enqueueExposure(name, (0, client_core_1._createGateExposure)(this._user, result, this._store.getExposureMapping()), options);
        this.$emt({ name: "gate_evaluation", gate: result });
        return result;
      }
      _getDynamicConfigImpl(name, options) {
        var _a, _b;
        const { result: evaluation, details } = this._store.getConfig(name);
        const config = (0, client_core_1._makeDynamicConfig)(name, details, evaluation);
        const overridden = (_b = (_a = this.overrideAdapter) === null || _a === void 0 ? void 0 : _a.getDynamicConfigOverride) === null || _b === void 0 ? void 0 : _b.call(_a, config, this._user, options);
        const result = overridden !== null && overridden !== void 0 ? overridden : config;
        this._enqueueExposure(name, (0, client_core_1._createConfigExposure)(this._user, result, this._store.getExposureMapping()), options);
        this.$emt({ name: "dynamic_config_evaluation", dynamicConfig: result });
        return result;
      }
      _getExperimentImpl(name, options) {
        var _a, _b, _c, _d;
        const { result: evaluation, details } = this._store.getConfig(name);
        const experiment = (0, client_core_1._makeExperiment)(name, details, evaluation);
        if (experiment.__evaluation != null) {
          experiment.__evaluation.secondary_exposures = (0, client_core_1._mapExposures)((_b = (_a = experiment.__evaluation) === null || _a === void 0 ? void 0 : _a.secondary_exposures) !== null && _b !== void 0 ? _b : [], this._store.getExposureMapping());
        }
        const overridden = (_d = (_c = this.overrideAdapter) === null || _c === void 0 ? void 0 : _c.getExperimentOverride) === null || _d === void 0 ? void 0 : _d.call(_c, experiment, this._user, options);
        const result = overridden !== null && overridden !== void 0 ? overridden : experiment;
        this._enqueueExposure(name, (0, client_core_1._createConfigExposure)(this._user, result, this._store.getExposureMapping()), options);
        this.$emt({ name: "experiment_evaluation", experiment: result });
        return result;
      }
      _getLayerImpl(name, options) {
        var _a, _b, _c;
        const { result: evaluation, details } = this._store.getLayer(name);
        const layer = (0, client_core_1._makeLayer)(name, details, evaluation);
        const overridden = (_b = (_a = this.overrideAdapter) === null || _a === void 0 ? void 0 : _a.getLayerOverride) === null || _b === void 0 ? void 0 : _b.call(_a, layer, this._user, options);
        if (options === null || options === void 0 ? void 0 : options.disableExposureLog) {
          this._logger.incrementNonExposureCount(name);
        }
        const result = (0, client_core_1._mergeOverride)(layer, overridden, (_c = overridden === null || overridden === void 0 ? void 0 : overridden.__value) !== null && _c !== void 0 ? _c : layer.__value, (param) => {
          if (options === null || options === void 0 ? void 0 : options.disableExposureLog) {
            return;
          }
          this._enqueueExposure(name, (0, client_core_1._createLayerParameterExposure)(this._user, result, param, this._store.getExposureMapping()), options);
        });
        this.$emt({ name: "layer_evaluation", layer: result });
        return result;
      }
      _getParameterStoreImpl(name, options) {
        var _a, _b;
        const { result: configuration, details } = this._store.getParamStore(name);
        this._logger.incrementNonExposureCount(name);
        const paramStore = {
          name,
          details,
          __configuration: configuration,
          get: (0, ParamStoreGetterFactory_1._makeParamStoreGetter)(this, configuration, options)
        };
        const overridden = (_b = (_a = this.overrideAdapter) === null || _a === void 0 ? void 0 : _a.getParamStoreOverride) === null || _b === void 0 ? void 0 : _b.call(_a, paramStore, options);
        if (overridden != null) {
          paramStore.__configuration = overridden.config;
          paramStore.details = overridden.details;
          paramStore.get = (0, ParamStoreGetterFactory_1._makeParamStoreGetter)(this, overridden.config, options);
        }
        return paramStore;
      }
    };
    exports.default = StatsigClient;
  }
});

// node_modules/@statsig/js-client/src/index.js
var require_src2 = __commonJS({
  "node_modules/@statsig/js-client/src/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StatsigClient = void 0;
    var client_core_1 = require_src();
    var StatsigClient_1 = require_StatsigClient();
    exports.StatsigClient = StatsigClient_1.default;
    __exportStar(require_src(), exports);
    var __STATSIG__ = Object.assign((0, client_core_1._getStatsigGlobal)(), {
      StatsigClient: StatsigClient_1.default
    });
    exports.default = __STATSIG__;
  }
});

// node_modules/@statsig/react-bindings/src/useStatsigInternalClientFactoryAsync.js
var require_useStatsigInternalClientFactoryAsync = __commonJS({
  "node_modules/@statsig/react-bindings/src/useStatsigInternalClientFactoryAsync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useStatsigInternalClientFactoryAsync = void 0;
    var react_1 = require_react();
    var client_core_1 = require_src();
    function useStatsigInternalClientFactoryAsync(factory, args) {
      const client = (0, react_1.useMemo)(() => {
        var _a;
        return (_a = (0, client_core_1._getInstance)(args.sdkKey)) !== null && _a !== void 0 ? _a : factory(args);
      }, []);
      const [isLoading, setIsLoading] = (0, react_1.useState)(client.loadingStatus !== "Ready");
      (0, react_1.useMemo)(() => {
        if (client.loadingStatus !== "Ready") {
          client.initializeAsync().catch(client_core_1.Log.error).finally(() => setIsLoading(false));
        }
      }, []);
      return { client, isLoading };
    }
    exports.useStatsigInternalClientFactoryAsync = useStatsigInternalClientFactoryAsync;
  }
});

// node_modules/@statsig/react-bindings/src/useClientAsyncInit.js
var require_useClientAsyncInit = __commonJS({
  "node_modules/@statsig/react-bindings/src/useClientAsyncInit.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useClientAsyncInit = void 0;
    var js_client_1 = require_src2();
    var useStatsigInternalClientFactoryAsync_1 = require_useStatsigInternalClientFactoryAsync();
    function useClientAsyncInit(sdkKey, initialUser, statsigOptions = null) {
      return (0, useStatsigInternalClientFactoryAsync_1.useStatsigInternalClientFactoryAsync)((args) => new js_client_1.StatsigClient(args.sdkKey, args.initialUser, args.statsigOptions), {
        sdkKey,
        initialUser,
        statsigOptions
      });
    }
    exports.useClientAsyncInit = useClientAsyncInit;
  }
});

// node_modules/@statsig/react-bindings/src/StatsigProvider.js
var require_StatsigProvider = __commonJS({
  "node_modules/@statsig/react-bindings/src/StatsigProvider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StatsigProvider = void 0;
    var jsx_runtime_1 = require_jsx_runtime();
    var react_1 = require_react();
    var client_core_1 = require_src();
    var StatsigContext_1 = require_StatsigContext();
    var useClientAsyncInit_1 = require_useClientAsyncInit();
    function StatsigProvider(props) {
      if (!("client" in props)) {
        return (0, jsx_runtime_1.jsx)(ConfigBasedStatsigProvider, Object.assign({}, props));
      }
      if ("sdkKey" in props || "user" in props) {
        client_core_1.Log.warn("Both client and configuration props (sdkKey, user) were provided to StatsigProvider. The client prop will be used and the configuration props will be ignored.");
      }
      return (0, jsx_runtime_1.jsx)(ClientBasedStatsigProvider, Object.assign({}, props));
    }
    exports.StatsigProvider = StatsigProvider;
    function ConfigBasedStatsigProvider(props) {
      const [renderVersion, setRenderVersion] = (0, react_1.useState)(0);
      const client = (0, useClientAsyncInit_1.useClientAsyncInit)(props.sdkKey, props.user, props.options).client;
      const [isLoading, setIsLoading] = (0, react_1.useState)(!_isReady(client));
      useStatsigClientSetup(client, setRenderVersion, setIsLoading);
      const contextValue = (0, react_1.useMemo)(() => ({
        renderVersion,
        client,
        isLoading
      }), [renderVersion, client, isLoading]);
      return (0, jsx_runtime_1.jsx)(StatsigContext_1.default.Provider, { value: contextValue, children: props.loadingComponent == null || !contextValue.isLoading ? props.children : props.loadingComponent });
    }
    function ClientBasedStatsigProvider(props) {
      const [renderVersion, setRenderVersion] = (0, react_1.useState)(0);
      const client = props.client;
      const [isLoading, setIsLoading] = (0, react_1.useState)(!_isReady(client));
      useStatsigClientSetup(client, setRenderVersion, setIsLoading);
      const contextValue = (0, react_1.useMemo)(() => ({
        renderVersion,
        client,
        isLoading
      }), [renderVersion, client, isLoading]);
      return (0, jsx_runtime_1.jsx)(StatsigContext_1.default.Provider, { value: contextValue, children: props.loadingComponent == null || !contextValue.isLoading ? props.children : props.loadingComponent });
    }
    function useStatsigClientSetup(client, setRenderVersion, setIsLoading) {
      (0, react_1.useEffect)(() => {
        const onValuesUpdated = () => {
          setRenderVersion((v) => v + 1);
          setIsLoading(!_isReady(client));
        };
        client_core_1.SDKType._setBindingType("react");
        client.$on("values_updated", onValuesUpdated);
        return () => {
          client.flush().catch((err) => client_core_1.Log.error("An error occurred during flush", err));
          client.off("values_updated", onValuesUpdated);
        };
      }, [client, setRenderVersion]);
    }
    function _isReady(client) {
      if ("isNoop" in client) {
        return true;
      }
      switch (client.loadingStatus) {
        case "Ready":
          return true;
        default:
          return false;
      }
    }
  }
});

// node_modules/@statsig/react-bindings/src/useStatsigInternalClientFactoryBootstrap.js
var require_useStatsigInternalClientFactoryBootstrap = __commonJS({
  "node_modules/@statsig/react-bindings/src/useStatsigInternalClientFactoryBootstrap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useStatsigInternalClientFactoryBootstrap = void 0;
    var react_1 = require_react();
    var client_core_1 = require_src();
    function useStatsigInternalClientFactoryBootstrap(factory, args) {
      const clientRef = (0, react_1.useRef)((0, client_core_1._getInstance)(args.sdkKey));
      return (0, react_1.useMemo)(() => {
        if (clientRef.current) {
          return clientRef.current;
        }
        const inst = factory(args);
        clientRef.current = inst;
        inst.dataAdapter.setData(args.initialValues);
        inst.initializeSync();
        return inst;
      }, []);
    }
    exports.useStatsigInternalClientFactoryBootstrap = useStatsigInternalClientFactoryBootstrap;
  }
});

// node_modules/@statsig/react-bindings/src/useClientBootstrapInit.js
var require_useClientBootstrapInit = __commonJS({
  "node_modules/@statsig/react-bindings/src/useClientBootstrapInit.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useClientBootstrapInit = void 0;
    var js_client_1 = require_src2();
    var useStatsigInternalClientFactoryBootstrap_1 = require_useStatsigInternalClientFactoryBootstrap();
    function useClientBootstrapInit(sdkKey, initialUser, initialValues, statsigOptions = null) {
      return (0, useStatsigInternalClientFactoryBootstrap_1.useStatsigInternalClientFactoryBootstrap)((args) => new js_client_1.StatsigClient(args.sdkKey, args.initialUser, args.statsigOptions), {
        sdkKey,
        initialUser,
        initialValues,
        statsigOptions
      });
    }
    exports.useClientBootstrapInit = useClientBootstrapInit;
  }
});

// node_modules/@statsig/react-bindings/src/useDynamicConfig.js
var require_useDynamicConfig = __commonJS({
  "node_modules/@statsig/react-bindings/src/useDynamicConfig.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var react_1 = require_react();
    var client_core_1 = require_src();
    var NoopEvaluationsClient_1 = require_NoopEvaluationsClient();
    var StatsigContext_1 = require_StatsigContext();
    function default_1(configName, options) {
      const { client, renderVersion } = (0, react_1.useContext)(StatsigContext_1.default);
      return (0, react_1.useMemo)(() => {
        if ((0, NoopEvaluationsClient_1.isNoopClient)(client)) {
          client_core_1.Log.warn(`useDynamicConfig hook failed to find a valid StatsigClient for dynamic config '${configName}'.`);
          return NoopEvaluationsClient_1.NoopEvaluationsClient.getDynamicConfig(configName, options);
        }
        return client.getDynamicConfig(configName, options);
      }, [
        configName,
        client,
        renderVersion,
        ...options ? Object.values(options) : []
      ]);
    }
    exports.default = default_1;
  }
});

// node_modules/@statsig/react-bindings/src/useExperiment.js
var require_useExperiment = __commonJS({
  "node_modules/@statsig/react-bindings/src/useExperiment.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var react_1 = require_react();
    var client_core_1 = require_src();
    var NoopEvaluationsClient_1 = require_NoopEvaluationsClient();
    var StatsigContext_1 = require_StatsigContext();
    function default_1(experimentName, options) {
      const { client, renderVersion } = (0, react_1.useContext)(StatsigContext_1.default);
      return (0, react_1.useMemo)(() => {
        if ((0, NoopEvaluationsClient_1.isNoopClient)(client)) {
          client_core_1.Log.warn(`useExperiment hook failed to find a valid Statsig client for experiment '${experimentName}'.`);
          return NoopEvaluationsClient_1.NoopEvaluationsClient.getExperiment(experimentName, options);
        }
        return client.getExperiment(experimentName, options);
      }, [
        experimentName,
        client,
        renderVersion,
        ...options ? Object.values(options) : []
      ]);
    }
    exports.default = default_1;
  }
});

// node_modules/@statsig/react-bindings/src/useFeatureGate.js
var require_useFeatureGate = __commonJS({
  "node_modules/@statsig/react-bindings/src/useFeatureGate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var react_1 = require_react();
    var client_core_1 = require_src();
    var NoopEvaluationsClient_1 = require_NoopEvaluationsClient();
    var StatsigContext_1 = require_StatsigContext();
    function default_1(gateName, options) {
      const { client, renderVersion } = (0, react_1.useContext)(StatsigContext_1.default);
      const gate = (0, react_1.useMemo)(() => {
        if ((0, NoopEvaluationsClient_1.isNoopClient)(client)) {
          client_core_1.Log.warn(`useFeatureGate hook failed to find a valid StatsigClient for gate '${gateName}'.`);
          return NoopEvaluationsClient_1.NoopEvaluationsClient.getFeatureGate(gateName, options);
        }
        return client.getFeatureGate(gateName, options);
      }, [
        gateName,
        client,
        renderVersion,
        ...options ? Object.values(options) : []
      ]);
      return gate;
    }
    exports.default = default_1;
  }
});

// node_modules/@statsig/react-bindings/src/useGateValue.js
var require_useGateValue = __commonJS({
  "node_modules/@statsig/react-bindings/src/useGateValue.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var react_1 = require_react();
    var client_core_1 = require_src();
    var NoopEvaluationsClient_1 = require_NoopEvaluationsClient();
    var StatsigContext_1 = require_StatsigContext();
    function default_1(gateName, options) {
      const { client, renderVersion } = (0, react_1.useContext)(StatsigContext_1.default);
      const gate = (0, react_1.useMemo)(() => {
        if ((0, NoopEvaluationsClient_1.isNoopClient)(client)) {
          client_core_1.Log.warn(`useGateValue hook failed to find a valid StatsigClient for gate '${gateName}'.`);
          return NoopEvaluationsClient_1.NoopEvaluationsClient.checkGate(gateName, options);
        }
        return client.checkGate(gateName, options);
      }, [
        gateName,
        client,
        renderVersion,
        ...options ? Object.values(options) : []
      ]);
      return gate;
    }
    exports.default = default_1;
  }
});

// node_modules/@statsig/react-bindings/src/useLayer.js
var require_useLayer = __commonJS({
  "node_modules/@statsig/react-bindings/src/useLayer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var react_1 = require_react();
    var client_core_1 = require_src();
    var NoopEvaluationsClient_1 = require_NoopEvaluationsClient();
    var StatsigContext_1 = require_StatsigContext();
    function default_1(layerName, options) {
      const { client, renderVersion } = (0, react_1.useContext)(StatsigContext_1.default);
      const layer = (0, react_1.useMemo)(() => {
        if ((0, NoopEvaluationsClient_1.isNoopClient)(client)) {
          client_core_1.Log.warn(`useLayer hook failed to find a valid Statsig client for layer '${layerName}'.`);
          return NoopEvaluationsClient_1.NoopEvaluationsClient.getLayer(layerName, options);
        }
        return client.getLayer(layerName, options);
      }, [
        layerName,
        client,
        renderVersion,
        ...options ? Object.values(options) : []
      ]);
      return layer;
    }
    exports.default = default_1;
  }
});

// node_modules/@statsig/react-bindings/src/useParameterStore.js
var require_useParameterStore = __commonJS({
  "node_modules/@statsig/react-bindings/src/useParameterStore.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var react_1 = require_react();
    var client_core_1 = require_src();
    var NoopEvaluationsClient_1 = require_NoopEvaluationsClient();
    var StatsigContext_1 = require_StatsigContext();
    function default_1(storeName, options) {
      const { client, renderVersion } = (0, react_1.useContext)(StatsigContext_1.default);
      const store = (0, react_1.useMemo)(() => {
        if ((0, NoopEvaluationsClient_1.isNoopClient)(client)) {
          client_core_1.Log.warn(`useParameterStore hook failed to find a valid StatsigClient for parameter store '${storeName}'.`);
          return NoopEvaluationsClient_1.NoopEvaluationsClient.getParameterStore(storeName, options);
        }
        return client.getParameterStore(storeName, options);
      }, [
        storeName,
        client,
        renderVersion,
        ...options ? Object.values(options) : []
      ]);
      return store;
    }
    exports.default = default_1;
  }
});

// node_modules/@statsig/react-bindings/src/useStatsigClient.js
var require_useStatsigClient = __commonJS({
  "node_modules/@statsig/react-bindings/src/useStatsigClient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useStatsigClient = void 0;
    var react_1 = require_react();
    var client_core_1 = require_src();
    var NoopEvaluationsClient_1 = require_NoopEvaluationsClient();
    var StatsigContext_1 = require_StatsigContext();
    function useStatsigClient() {
      const { client: anyClient, renderVersion, isLoading } = (0, react_1.useContext)(StatsigContext_1.default);
      const client = (0, react_1.useMemo)(() => {
        if ((0, NoopEvaluationsClient_1.isNoopClient)(anyClient)) {
          client_core_1.Log.warn("Attempting to retrieve a StatsigClient but none was set.");
          return NoopEvaluationsClient_1.NoopEvaluationsClient;
        }
        return anyClient;
      }, [anyClient, renderVersion]);
      const deps = [client, renderVersion];
      const checkGate = (0, react_1.useCallback)((name, options) => {
        return client.checkGate(name, options);
      }, deps);
      const getFeatureGate = (0, react_1.useCallback)((name, options) => {
        return client.getFeatureGate(name, options);
      }, deps);
      const getDynamicConfig = (0, react_1.useCallback)((name, options) => {
        return client.getDynamicConfig(name, options);
      }, deps);
      const getExperiment = (0, react_1.useCallback)((name, options) => {
        return client.getExperiment(name, options);
      }, deps);
      const getLayer = (0, react_1.useCallback)((name, options) => {
        return client.getLayer(name, options);
      }, deps);
      const getParameterStore = (0, react_1.useCallback)((name, options) => {
        return client.getParameterStore(name, options);
      }, deps);
      const logEvent = (0, react_1.useCallback)((eventName, value, metadata) => {
        if (typeof eventName === "string") {
          return client.logEvent(eventName, value, metadata);
        }
        return client.logEvent(eventName);
      }, deps);
      return (0, react_1.useMemo)(() => {
        return {
          client,
          checkGate,
          getFeatureGate,
          getDynamicConfig,
          getExperiment,
          getLayer,
          getParameterStore,
          logEvent,
          isLoading
        };
      }, [
        client,
        checkGate,
        getFeatureGate,
        getDynamicConfig,
        getExperiment,
        getLayer,
        getParameterStore,
        logEvent,
        isLoading
      ]);
    }
    exports.useStatsigClient = useStatsigClient;
  }
});

// node_modules/@statsig/react-bindings/src/useStatsigUser.js
var require_useStatsigUser = __commonJS({
  "node_modules/@statsig/react-bindings/src/useStatsigUser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useStatsigUser = void 0;
    var react_1 = require_react();
    var StatsigContext_1 = require_StatsigContext();
    var useStatsigClient_1 = require_useStatsigClient();
    function getClientUser(client) {
      const context = client.getContext();
      return context.user;
    }
    function useStatsigUser() {
      const { client } = (0, useStatsigClient_1.useStatsigClient)();
      const { renderVersion } = (0, react_1.useContext)(StatsigContext_1.default);
      const memoUser = (0, react_1.useMemo)(() => {
        return getClientUser(client);
      }, [client, renderVersion]);
      return {
        user: memoUser,
        updateUserSync: (0, react_1.useCallback)((arg) => {
          if (typeof arg === "function") {
            arg = arg(getClientUser(client));
          }
          return client.updateUserSync(arg);
        }, [client]),
        updateUserAsync: (0, react_1.useCallback)((arg) => {
          if (typeof arg === "function") {
            arg = arg(getClientUser(client));
          }
          return client.updateUserAsync(arg);
        }, [client])
      };
    }
    exports.useStatsigUser = useStatsigUser;
  }
});

// node_modules/@statsig/react-bindings/src/index.js
var require_src3 = __commonJS({
  "node_modules/@statsig/react-bindings/src/index.js"(exports) {
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useStatsigUser = exports.useStatsigInternalClientFactoryBootstrap = exports.useStatsigInternalClientFactoryAsync = exports.useStatsigClient = exports.useParameterStore = exports.useLayer = exports.useGateValue = exports.useFeatureGate = exports.useExperiment = exports.useDynamicConfig = exports.useClientBootstrapInit = exports.useClientAsyncInit = exports.StatsigProvider = exports.StatsigContext = void 0;
    var client_core_1 = require_src();
    var StatsigContext_1 = require_StatsigContext();
    exports.StatsigContext = StatsigContext_1.default;
    var StatsigProvider_1 = require_StatsigProvider();
    Object.defineProperty(exports, "StatsigProvider", { enumerable: true, get: function() {
      return StatsigProvider_1.StatsigProvider;
    } });
    var useClientAsyncInit_1 = require_useClientAsyncInit();
    Object.defineProperty(exports, "useClientAsyncInit", { enumerable: true, get: function() {
      return useClientAsyncInit_1.useClientAsyncInit;
    } });
    var useClientBootstrapInit_1 = require_useClientBootstrapInit();
    Object.defineProperty(exports, "useClientBootstrapInit", { enumerable: true, get: function() {
      return useClientBootstrapInit_1.useClientBootstrapInit;
    } });
    var useDynamicConfig_1 = require_useDynamicConfig();
    exports.useDynamicConfig = useDynamicConfig_1.default;
    var useExperiment_1 = require_useExperiment();
    exports.useExperiment = useExperiment_1.default;
    var useFeatureGate_1 = require_useFeatureGate();
    exports.useFeatureGate = useFeatureGate_1.default;
    var useGateValue_1 = require_useGateValue();
    exports.useGateValue = useGateValue_1.default;
    var useLayer_1 = require_useLayer();
    exports.useLayer = useLayer_1.default;
    var useParameterStore_1 = require_useParameterStore();
    exports.useParameterStore = useParameterStore_1.default;
    var useStatsigClient_1 = require_useStatsigClient();
    Object.defineProperty(exports, "useStatsigClient", { enumerable: true, get: function() {
      return useStatsigClient_1.useStatsigClient;
    } });
    var useStatsigInternalClientFactoryAsync_1 = require_useStatsigInternalClientFactoryAsync();
    Object.defineProperty(exports, "useStatsigInternalClientFactoryAsync", { enumerable: true, get: function() {
      return useStatsigInternalClientFactoryAsync_1.useStatsigInternalClientFactoryAsync;
    } });
    var useStatsigInternalClientFactoryBootstrap_1 = require_useStatsigInternalClientFactoryBootstrap();
    Object.defineProperty(exports, "useStatsigInternalClientFactoryBootstrap", { enumerable: true, get: function() {
      return useStatsigInternalClientFactoryBootstrap_1.useStatsigInternalClientFactoryBootstrap;
    } });
    var useStatsigUser_1 = require_useStatsigUser();
    Object.defineProperty(exports, "useStatsigUser", { enumerable: true, get: function() {
      return useStatsigUser_1.useStatsigUser;
    } });
    __exportStar(require_src2(), exports);
    Object.assign((0, client_core_1._getStatsigGlobal)(), {
      StatsigContext: StatsigContext_1.default,
      StatsigProvider: StatsigProvider_1.StatsigProvider,
      useClientAsyncInit: useClientAsyncInit_1.useClientAsyncInit,
      useClientBootstrapInit: useClientBootstrapInit_1.useClientBootstrapInit,
      useDynamicConfig: useDynamicConfig_1.default,
      useExperiment: useExperiment_1.default,
      useFeatureGate: useFeatureGate_1.default,
      useGateValue: useGateValue_1.default,
      useLayer: useLayer_1.default,
      useParameterStore: useParameterStore_1.default,
      useStatsigClient: useStatsigClient_1.useStatsigClient,
      useStatsigInternalClientFactoryAsync: useStatsigInternalClientFactoryAsync_1.useStatsigInternalClientFactoryAsync,
      useStatsigInternalClientFactoryBootstrap: useStatsigInternalClientFactoryBootstrap_1.useStatsigInternalClientFactoryBootstrap,
      useStatsigUser: useStatsigUser_1.useStatsigUser
    });
  }
});
export default require_src3();
//# sourceMappingURL=@statsig_react-bindings.js.map
