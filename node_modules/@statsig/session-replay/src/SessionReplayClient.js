"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SessionReplayClient = void 0;
const rrweb = require("rrweb");
const client_core_1 = require("@statsig/client-core");
const TIMEOUT_MS = 1000 * 60 * 60 * 4; // 4 hours
const CHECKOUT_WINDOW_MS = 1000 * 30; // 30 seconds
class SessionReplayClient {
    constructor() {
        this._startTimestamp = null;
        this._endTimestamp = null;
    }
    record(callback, config, stopCallback, keepRollingWindow = false) {
        if ((0, client_core_1._getDocumentSafe)() == null) {
            return;
        }
        // Always reset session id and tracking fields for a new recording
        this._startTimestamp = null;
        this._endTimestamp = null;
        this._stopCallback = stopCallback;
        if (this._stopFn) {
            return;
        }
        const emit = (event, isCheckOut) => {
            var _a, _b, _c;
            if (keepRollingWindow) {
                // Reset start at each checkout
                this._startTimestamp = isCheckOut
                    ? event.timestamp
                    : (_a = this._startTimestamp) !== null && _a !== void 0 ? _a : event.timestamp;
            }
            else {
                // Reset start only for the first event
                (_b = this._startTimestamp) !== null && _b !== void 0 ? _b : (this._startTimestamp = event.timestamp);
            }
            // Always keep a running end timestamp
            this._endTimestamp = event.timestamp;
            let clickCount = 0;
            // Count clicks only for events representing a click
            if (_isClickEvent(event)) {
                clickCount++;
            }
            callback(Object.assign(Object.assign({}, event), { eventIndex: 0 }), {
                startTime: this._startTimestamp,
                endTime: this._endTimestamp,
                clickCount,
            }, isCheckOut !== null && isCheckOut !== void 0 ? isCheckOut : false);
            if (this._endTimestamp - this._startTimestamp > TIMEOUT_MS) {
                (_c = this._stopFn) === null || _c === void 0 ? void 0 : _c.call(this);
                if (this._stopCallback) {
                    this._stopCallback();
                }
            }
        };
        this._stopFn = _minifiedAwareRecord(emit, config, keepRollingWindow);
    }
    stop() {
        if (this._stopFn) {
            this._stopFn();
            this._stopFn = undefined;
        }
    }
    isRecording() {
        return this._stopFn != null;
    }
}
exports.SessionReplayClient = SessionReplayClient;
/**
 * We do a simple concat of rrweb during minification.
 * This function ensures we handle both "npm" and "<script ..>" install options.
 */
function _minifiedAwareRecord(emit, config, keepRollingWindow) {
    const record = typeof rrweb === 'function' ? rrweb : rrweb.record;
    if (keepRollingWindow) {
        return record(Object.assign(Object.assign({}, config), { emit, checkoutEveryNms: CHECKOUT_WINDOW_MS }));
    }
    else {
        return record(Object.assign(Object.assign({}, config), { emit }));
    }
}
function _isClickEvent(event) {
    // we use the raw number so we can support the minified rrweb file.
    return (event.type === 3 && // rrweb.EventType.IncrementalSnapshot &&
        event.data.source === 2 && // rrweb.IncrementalSource.MouseInteraction &&
        (event.data.type === 2 /* rrweb.MouseInteractions.Click */ ||
            event.data.type === 4) /* rrweb.MouseInteractions.DbClick */);
}
