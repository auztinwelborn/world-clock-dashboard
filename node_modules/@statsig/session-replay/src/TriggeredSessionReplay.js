"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TriggeredSessionReplay = exports.runStatsigTriggeredSessionReplay = exports.StatsigTriggeredSessionReplayPlugin = void 0;
const client_core_1 = require("@statsig/client-core");
const SessionReplayBase_1 = require("./SessionReplayBase");
const SessionReplayUtils_1 = require("./SessionReplayUtils");
class StatsigTriggeredSessionReplayPlugin {
    constructor(options) {
        this.options = options;
        this.__plugin = 'triggered-session-replay';
    }
    bind(client) {
        runStatsigTriggeredSessionReplay(client, this.options);
    }
}
exports.StatsigTriggeredSessionReplayPlugin = StatsigTriggeredSessionReplayPlugin;
function runStatsigTriggeredSessionReplay(client, options) {
    new TriggeredSessionReplay(client, options);
}
exports.runStatsigTriggeredSessionReplay = runStatsigTriggeredSessionReplay;
class TriggeredSessionReplay extends SessionReplayBase_1.SessionReplayBase {
    constructor(client, options) {
        var _a;
        super(client, options);
        this._runningEventData = [];
        this._isActiveRecording = false;
        this._subscribeToClientEvents(options);
        if (options === null || options === void 0 ? void 0 : options.autoStartRecording) {
            this._attemptToStartRecording((_a = this._options) === null || _a === void 0 ? void 0 : _a.forceRecording);
        }
        else if (options === null || options === void 0 ? void 0 : options.keepRollingWindow) {
            this._attemptToStartRollingWindow();
        }
    }
    _subscribeToClientEvents(options) {
        this._subscribeToValuesUpdated(options);
        this._subscribeToLogEventCalled();
        this._subscribeToGateEvaluation();
        this._subscribeToExperimentEvaluation();
    }
    _subscribeToValuesUpdated(options) {
        this._client.$on('values_updated', () => {
            var _a;
            if (!this._wasStopped) {
                if (options === null || options === void 0 ? void 0 : options.autoStartRecording) {
                    this._attemptToStartRecording((_a = this._options) === null || _a === void 0 ? void 0 : _a.forceRecording);
                }
                else if (options === null || options === void 0 ? void 0 : options.keepRollingWindow) {
                    this._attemptToStartRollingWindow();
                }
            }
        });
    }
    _subscribeToLogEventCalled() {
        this._client.$on('log_event_called', (event) => {
            var _a;
            if (this._wasStopped) {
                return;
            }
            const values = this._client.getContext().values;
            const passedTargeting = values === null || values === void 0 ? void 0 : values.passes_session_recording_targeting;
            if (passedTargeting === false ||
                (values === null || values === void 0 ? void 0 : values.session_recording_event_triggers) == null) {
                return;
            }
            const trigger = values.session_recording_event_triggers[event.event.eventName];
            if (trigger == null) {
                return;
            }
            if (trigger.passes_sampling === false) {
                return;
            }
            const targetValues = trigger.values;
            if (targetValues == null) {
                this._attemptToStartRecording(true);
                return;
            }
            if (targetValues.includes(String((_a = event.event.value) !== null && _a !== void 0 ? _a : ''))) {
                this._attemptToStartRecording(true);
                return;
            }
        });
    }
    _subscribeToGateEvaluation() {
        this._client.$on('gate_evaluation', (event) => {
            this._tryStartExposureRecording(event.gate.name, String(event.gate.value));
        });
    }
    _subscribeToExperimentEvaluation() {
        this._client.$on('experiment_evaluation', (event) => {
            var _a;
            this._tryStartExposureRecording(event.experiment.name, (_a = event.experiment.groupName) !== null && _a !== void 0 ? _a : '');
        });
    }
    _tryStartExposureRecording(name, value) {
        var _a;
        if (this._wasStopped) {
            return;
        }
        const values = this._client.getContext().values;
        const passedTargeting = values === null || values === void 0 ? void 0 : values.passes_session_recording_targeting;
        if (passedTargeting === false ||
            (values === null || values === void 0 ? void 0 : values.session_recording_exposure_triggers) == null) {
            return;
        }
        const trigger = (_a = values.session_recording_exposure_triggers[name]) !== null && _a !== void 0 ? _a : values.session_recording_exposure_triggers[(0, client_core_1._DJB2)(name)];
        if (trigger == null) {
            return;
        }
        if (trigger.passes_sampling === false) {
            return;
        }
        const targetValues = trigger.values;
        if (targetValues == null) {
            this._attemptToStartRecording(true);
            return;
        }
        if (targetValues.includes(value)) {
            this._attemptToStartRecording(true);
            return;
        }
    }
    forceStartRecording() {
        super.forceStartRecording();
    }
    stopRecording() {
        this._isActiveRecording = false;
        this._runningEventData = [];
        super.stopRecording();
    }
    _handleStartActiveRecording() {
        this._isActiveRecording = true;
        if (this._runningEventData.length === 0) {
            return;
        }
        const currentEvents = this._runningEventData.map((e) => e.events).flat();
        for (let i = 0; i < currentEvents.length; i++) {
            currentEvents[i].event.eventIndex = i;
            this._sessionData.clickCount += currentEvents[i].data.clickCount;
            this._sessionData.startTime =
                this._sessionData.startTime === -1
                    ? currentEvents[i].data.startTime
                    : Math.min(this._sessionData.startTime, currentEvents[i].data.startTime);
            this._sessionData.endTime = Math.max(this._sessionData.endTime, currentEvents[i].data.endTime);
        }
        this._events = currentEvents.map((e) => e.event);
        this._currentEventIndex = currentEvents.length;
        if ((0, client_core_1._isCurrentlyVisible)()) {
            this._bumpSessionIdleTimerAndLogRecording();
        }
        else {
            this._logRecording();
        }
        // stop recording and since it will be started again
        this._replayer.stop();
    }
    _shutdown(endReason) {
        this._isActiveRecording = false;
        this._runningEventData = [];
        super._shutdownImpl(endReason);
    }
    _onRecordingEvent(event, data, isCheckOut) {
        if (!this._isActiveRecording) {
            // The session has expired so we should clear the current data
            if (this._currentSessionID !== this._getSessionIdFromClient()) {
                this._shutdown('session_expired');
                return;
            }
            if ((isCheckOut && event.type === 4) || // Type 4 and type 2 both show up as checkout events but we only want to start a new entry for type 4
                this._runningEventData.length === 0) {
                // We only want to keep two entries
                if (this._runningEventData.length > 1) {
                    this._runningEventData.shift();
                }
                this._runningEventData.push({ events: [{ event, data }] });
            }
            else {
                this._runningEventData[this._runningEventData.length - 1].events.push({
                    event,
                    data,
                });
            }
            return;
        }
        super._onRecordingEvent(event, data);
    }
    _attemptToStartRollingWindow() {
        var _a, _b;
        const values = this._client.getContext().values;
        if ((values === null || values === void 0 ? void 0 : values.passes_session_recording_targeting) === false) {
            this._shutdown();
            return;
        }
        if (this._replayer.isRecording()) {
            return;
        }
        this._replayer.record((e, d, isCheckOut) => this._onRecordingEvent(e, d, isCheckOut), (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.rrwebConfig) !== null && _b !== void 0 ? _b : {}, () => {
            this._shutdown();
        }, true);
    }
    _attemptToStartRecording(force = false) {
        var _a, _b;
        if (this._totalLogs >= SessionReplayUtils_1.MAX_LOGS) {
            return;
        }
        const values = this._client.getContext().values;
        if ((values === null || values === void 0 ? void 0 : values.recording_blocked) === true) {
            this._shutdown();
            return;
        }
        if (!force && (values === null || values === void 0 ? void 0 : values.can_record_session) !== true) {
            this._shutdown();
            return;
        }
        if ((values === null || values === void 0 ? void 0 : values.passes_session_recording_targeting) === false) {
            this._shutdown();
            return;
        }
        this._handleStartActiveRecording();
        this._wasStopped = false;
        client_core_1.StatsigMetadataProvider.add({ isRecordingSession: 'true' });
        if (this._replayer.isRecording()) {
            return;
        }
        this._replayer.record((e, d, isCheckOut) => this._onRecordingEvent(e, d, isCheckOut), (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.rrwebConfig) !== null && _b !== void 0 ? _b : {}, () => {
            this._shutdown();
        });
    }
}
exports.TriggeredSessionReplay = TriggeredSessionReplay;
