"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AutoCapture = exports.runStatsigAutoCapture = exports.StatsigAutoCapturePlugin = void 0;
const client_core_1 = require("@statsig/client-core");
const AutoCaptureEvent_1 = require("./AutoCaptureEvent");
const EngagementManager_1 = require("./EngagementManager");
const RageClickManager_1 = require("./RageClickManager");
const commonUtils_1 = require("./commonUtils");
const eventUtils_1 = require("./eventUtils");
const metadataUtils_1 = require("./metadataUtils");
const AUTO_EVENT_MAPPING = {
    submit: AutoCaptureEvent_1.AutoCaptureEventName.FORM_SUBMIT,
    click: AutoCaptureEvent_1.AutoCaptureEventName.CLICK,
};
class StatsigAutoCapturePlugin {
    constructor(_options) {
        this._options = _options;
        this.__plugin = 'auto-capture';
    }
    bind(client) {
        runStatsigAutoCapture(client, this._options);
    }
}
exports.StatsigAutoCapturePlugin = StatsigAutoCapturePlugin;
function runStatsigAutoCapture(client, options) {
    return new AutoCapture(client, options);
}
exports.runStatsigAutoCapture = runStatsigAutoCapture;
class AutoCapture {
    constructor(_client, options) {
        var _a, _b, _c;
        this._client = _client;
        this._disabledEvents = {};
        this._previousLoggedPageViewUrl = null;
        this._hasLoggedPageViewEnd = false;
        const { sdkKey, errorBoundary, values } = _client.getContext();
        this._disabledEvents = (_b = (_a = values === null || values === void 0 ? void 0 : values.auto_capture_settings) === null || _a === void 0 ? void 0 : _a.disabled_events) !== null && _b !== void 0 ? _b : {};
        this._errorBoundary = errorBoundary;
        this._errorBoundary.wrap(this);
        this._client.$on('values_updated', () => {
            var _a, _b;
            const values = this._client.getContext().values;
            this._disabledEvents =
                (_b = (_a = values === null || values === void 0 ? void 0 : values.auto_capture_settings) === null || _a === void 0 ? void 0 : _a.disabled_events) !== null && _b !== void 0 ? _b : this._disabledEvents;
        });
        this._engagementManager = new EngagementManager_1.EngagementManager();
        this._rageClickManager = new RageClickManager_1.default();
        this._eventFilterFunc = options === null || options === void 0 ? void 0 : options.eventFilterFunc;
        const doc = (0, client_core_1._getDocumentSafe)();
        if (!(0, client_core_1._isServerEnv)()) {
            __STATSIG__ = (0, client_core_1._getStatsigGlobal)();
            const instances = (_c = __STATSIG__.acInstances) !== null && _c !== void 0 ? _c : {};
            instances[sdkKey] = this;
            __STATSIG__.acInstances = instances;
        }
        if ((doc === null || doc === void 0 ? void 0 : doc.readyState) === 'loading') {
            doc.addEventListener('DOMContentLoaded', () => this._initialize());
            return;
        }
        this._initialize();
    }
    _addEventHandlers() {
        const win = (0, client_core_1._getWindowSafe)();
        const doc = (0, client_core_1._getDocumentSafe)();
        if (!win || !doc) {
            return;
        }
        const eventHandler = (event, userAction = true) => {
            var _a;
            const e = event || ((_a = (0, client_core_1._getWindowSafe)()) === null || _a === void 0 ? void 0 : _a.event);
            this._autoLogEvent(e);
            if (userAction) {
                this._engagementManager.bumpInactiveTimer();
            }
            if (e.type === 'click' && e instanceof MouseEvent) {
                const isRageClick = this._rageClickManager.isRageClick(e.clientX, e.clientY, Date.now());
                if (isRageClick) {
                    this._logRageClick(e);
                }
            }
        };
        (0, commonUtils_1._registerEventHandler)(doc, 'click', (e) => eventHandler(e));
        (0, commonUtils_1._registerEventHandler)(doc, 'submit', (e) => eventHandler(e));
        (0, commonUtils_1._registerEventHandler)(win, 'error', (e) => eventHandler(e, false));
        (0, commonUtils_1._registerEventHandler)(win, 'pagehide', () => this._tryLogPageViewEnd());
        (0, commonUtils_1._registerEventHandler)(win, 'beforeunload', () => this._tryLogPageViewEnd());
    }
    _addPageViewTracking() {
        const win = (0, client_core_1._getWindowSafe)();
        const doc = (0, client_core_1._getDocumentSafe)();
        if (!win || !doc) {
            return;
        }
        (0, commonUtils_1._registerEventHandler)(win, 'popstate', () => this._tryLogPageView());
        window.history.pushState = new Proxy(window.history.pushState, {
            apply: (target, thisArg, [state, unused, url]) => {
                target.apply(thisArg, [state, unused, url]);
                this._tryLogPageView();
            },
        });
        this._tryLogPageView();
    }
    _autoLogEvent(event) {
        var _a;
        const eventType = (_a = event.type) === null || _a === void 0 ? void 0 : _a.toLowerCase();
        if (eventType === 'error' && event instanceof ErrorEvent) {
            this._logError(event);
            return;
        }
        const target = (0, commonUtils_1._getTargetNode)(event);
        if (!target) {
            return;
        }
        if (!(0, commonUtils_1._shouldLogEvent)(event, target)) {
            return;
        }
        const eventName = AUTO_EVENT_MAPPING[eventType];
        if (!eventName) {
            return;
        }
        const { value, metadata } = (0, eventUtils_1._gatherEventData)(target);
        const allMetadata = (0, metadataUtils_1._gatherAllMetadata)((0, commonUtils_1._getSafeUrl)());
        this._enqueueAutoCapture(eventName, value, Object.assign(Object.assign({}, allMetadata), metadata));
    }
    _initialize() {
        this._engagementManager.startInactivityTracking(() => this._tryLogPageViewEnd(true));
        this._addEventHandlers();
        this._addPageViewTracking();
        this._logSessionStart();
        this._logPerformance();
    }
    _logError(event) {
        const error = (event === null || event === void 0 ? void 0 : event.error) || {};
        let errorStr = error;
        if (typeof error === 'object') {
            try {
                errorStr = JSON.stringify(error);
            }
            catch (e) {
                errorStr =
                    typeof (error === null || error === void 0 ? void 0 : error.toString) === 'function'
                        ? error.toString()
                        : 'Unknown Error';
            }
        }
        this._enqueueAutoCapture(AutoCaptureEvent_1.AutoCaptureEventName.ERROR, event.message, {
            message: event.message,
            filename: event.filename,
            lineno: event.lineno,
            colno: event.colno,
            error_str: errorStr,
        });
    }
    _logSessionStart() {
        const session = this._getSessionFromClient();
        try {
            if (!this._isNewSession(session)) {
                return;
            }
            this._enqueueAutoCapture(AutoCaptureEvent_1.AutoCaptureEventName.SESSION_START, (0, commonUtils_1._getSanitizedPageUrl)(), { sessionID: session.data.sessionID }, { flushImmediately: true });
        }
        catch (err) {
            this._errorBoundary.logError('AC::logSession', err);
        }
    }
    _tryLogPageView() {
        const url = (0, commonUtils_1._getSafeUrl)();
        const last = this._previousLoggedPageViewUrl;
        if (last && url.href === last.href) {
            return;
        }
        this._engagementManager.setLastPageViewTime(Date.now());
        this._previousLoggedPageViewUrl = url;
        this._hasLoggedPageViewEnd = false;
        const payload = (0, metadataUtils_1._gatherAllMetadata)(url);
        this._enqueueAutoCapture(AutoCaptureEvent_1.AutoCaptureEventName.PAGE_VIEW, (0, commonUtils_1._getSanitizedPageUrl)(), payload, {
            flushImmediately: true,
            addNewSessionMetadata: true,
        });
        this._engagementManager.bumpInactiveTimer();
    }
    _tryLogPageViewEnd(dueToInactivity = false) {
        if (this._hasLoggedPageViewEnd) {
            return;
        }
        this._hasLoggedPageViewEnd = true;
        const scrollMetrics = this._engagementManager.getScrollMetrics();
        const pageViewLength = this._engagementManager.getPageViewLength();
        this._enqueueAutoCapture(AutoCaptureEvent_1.AutoCaptureEventName.PAGE_VIEW_END, (0, commonUtils_1._getSanitizedPageUrl)(), Object.assign(Object.assign({}, scrollMetrics), { pageViewLength,
            dueToInactivity }), {
            flushImmediately: true,
        });
    }
    _logRageClick(e) {
        const { value, metadata } = (0, eventUtils_1._gatherEventData)(e.target);
        this._enqueueAutoCapture(AutoCaptureEvent_1.AutoCaptureEventName.RAGE_CLICK, value, Object.assign(Object.assign({ x: e.clientX, y: e.clientY, timestamp: Date.now() }, (0, metadataUtils_1._gatherAllMetadata)((0, commonUtils_1._getSafeUrl)())), metadata));
    }
    _logPerformance() {
        const win = (0, client_core_1._getWindowSafe)();
        if (!win || !win.performance) {
            return;
        }
        if (typeof (win === null || win === void 0 ? void 0 : win.performance) === 'undefined' ||
            typeof win.performance.getEntriesByType !== 'function' ||
            typeof win.performance.getEntriesByName !== 'function') {
            return;
        }
        setTimeout(() => {
            const metadata = {};
            const navEntries = win.performance.getEntriesByType('navigation');
            if (navEntries &&
                navEntries.length > 0 &&
                navEntries[0] instanceof PerformanceNavigationTiming) {
                const nav = navEntries[0];
                metadata['load_time_ms'] = nav.duration;
                metadata['dom_interactive_time_ms'] =
                    nav.domInteractive - nav.startTime;
                metadata['redirect_count'] = nav.redirectCount;
                metadata['transfer_bytes'] = nav.transferSize;
            }
            const fpEntries = win.performance.getEntriesByName('first-contentful-paint');
            if (fpEntries &&
                fpEntries.length > 0 &&
                fpEntries[0] instanceof PerformancePaintTiming) {
                metadata['first_contentful_paint_time_ms'] = fpEntries[0].startTime;
            }
            this._enqueueAutoCapture(AutoCaptureEvent_1.AutoCaptureEventName.PERFORMANCE, (0, commonUtils_1._getSanitizedPageUrl)(), Object.assign(Object.assign({}, metadata), (0, metadataUtils_1._getNetworkInfo)()));
        }, 1);
    }
    _enqueueAutoCapture(eventName, value, metadata, options) {
        var _a, _b, _c;
        const subname = eventName.slice('auto_capture::'.length);
        if (this._disabledEvents[eventName] || this._disabledEvents[subname]) {
            return;
        }
        const session = this._getSessionFromClient();
        try {
            const logMetadata = Object.assign({ sessionID: session.data.sessionID, page_url: (_c = (_b = (_a = (0, client_core_1._getWindowSafe)()) === null || _a === void 0 ? void 0 : _a.location) === null || _b === void 0 ? void 0 : _b.href) !== null && _c !== void 0 ? _c : '' }, metadata);
            if (options === null || options === void 0 ? void 0 : options.addNewSessionMetadata) {
                logMetadata['isNewSession'] = String(this._isNewSession(session));
            }
            const event = {
                eventName,
                value,
                metadata: logMetadata,
            };
            if (this._eventFilterFunc && !this._eventFilterFunc(event)) {
                return;
            }
            this._client.logEvent(event);
            if (options === null || options === void 0 ? void 0 : options.flushImmediately) {
                this._client.flush().catch((e) => {
                    client_core_1.Log.error(e);
                });
            }
        }
        catch (err) {
            this._errorBoundary.logError('AC::enqueue', err);
        }
    }
    _isNewSession(session) {
        // within the last second
        return Math.abs(session.data.startTime - Date.now()) < 1000;
    }
    _getSessionFromClient() {
        return this._client.getContext().session;
    }
}
exports.AutoCapture = AutoCapture;
