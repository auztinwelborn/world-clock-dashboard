"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports._getMetadataFromElement = exports._gatherEventData = void 0;
const client_core_1 = require("@statsig/client-core");
const commonUtils_1 = require("./commonUtils");
const MAX_ATTRIBUTE_LENGTH = 1000;
const MAX_CLASS_LIST_LENGTH = 100;
const MAX_SELECTOR_DEPTH = 50;
function _gatherEventData(target) {
    const tagName = target.tagName.toLowerCase();
    const metadata = {};
    const value = (0, client_core_1._getCurrentPageUrlSafe)() || '';
    metadata['tagName'] = tagName;
    const elementMetadata = _getMetadataFromElement(target);
    Object.assign(metadata, elementMetadata);
    if (tagName === 'form') {
        Object.assign(metadata, _getFormMetadata(target));
    }
    if (['input', 'select', 'textarea'].includes(tagName) &&
        target.getAttribute('type') !== 'password') {
        Object.assign(metadata, _getInputMetadata(target));
    }
    const anchor = (0, commonUtils_1._getAnchorNodeInHierarchy)(target);
    if (anchor) {
        Object.assign(metadata, _getAnchorMetadata(anchor));
    }
    if (tagName === 'button' || anchor) {
        Object.assign(metadata, _getButtonMetadata(anchor || target));
    }
    return { value, metadata };
}
exports._gatherEventData = _gatherEventData;
function _getFormMetadata(target) {
    var _a;
    const metadata = {};
    metadata['action'] = target.getAttribute('action');
    metadata['method'] = (_a = target.getAttribute('method')) !== null && _a !== void 0 ? _a : 'GET';
    metadata['formName'] = target.getAttribute('name');
    metadata['formId'] = target.getAttribute('id');
    return metadata;
}
function _getInputMetadata(target) {
    const metadata = {};
    metadata['content'] = target.value;
    metadata['inputName'] = target.getAttribute('name');
    return metadata;
}
function _getAnchorMetadata(anchor) {
    const metadata = {};
    metadata['href'] = anchor.getAttribute('href');
    return metadata;
}
function _getButtonMetadata(target) {
    const metadata = {};
    metadata['content'] = (target.textContent || '').trim();
    const dataset = _gatherDatasetProperties(target);
    Object.assign(metadata, dataset);
    return metadata;
}
function _gatherDatasetProperties(el) {
    const dataset = {};
    if (!el) {
        return dataset;
    }
    const attr = el === null || el === void 0 ? void 0 : el.dataset;
    if (!attr) {
        return dataset;
    }
    for (const key in attr) {
        dataset[`data-${key}`] = attr[key] || '';
    }
    return dataset;
}
function _truncateString(str, maxLength) {
    if (!str)
        return null;
    return str.length > maxLength ? str.substring(0, maxLength) + '...' : str;
}
function _getMetadataFromElement(target) {
    const metadata = {};
    const classList = Array.from(target.classList);
    metadata['classList'] =
        classList.length > 0 ? classList.slice(0, MAX_CLASS_LIST_LENGTH) : null;
    metadata['class'] = _normalizeClassAttribute(_truncateString(target.getAttribute('class'), MAX_ATTRIBUTE_LENGTH) || '');
    metadata['id'] = _truncateString(target.getAttribute('id'), MAX_ATTRIBUTE_LENGTH);
    metadata['ariaLabel'] = _truncateString(target.getAttribute('aria-label'), MAX_ATTRIBUTE_LENGTH);
    metadata['selector'] = _generateCssSelector(target);
    return metadata;
}
exports._getMetadataFromElement = _getMetadataFromElement;
function _normalizeClassAttribute(className) {
    return className.replace(/\s+/g, ' ').trim();
}
function hasNextSiblingWithSameTag(element) {
    let sibling = element.nextElementSibling;
    while (sibling) {
        if (sibling.tagName === element.tagName) {
            return true;
        }
        sibling = sibling.nextElementSibling;
    }
    return false;
}
function getElementSelector(element) {
    const tagName = element.tagName.toLowerCase();
    // 1. Use ID if available
    if (element.id) {
        return `#${element.id}`;
    }
    // 2. Build class-based selector
    let selector = tagName;
    if (element.className && typeof element.className === 'string') {
        const classes = element.className.trim().split(/\s+/);
        if (classes.length > 0 && classes[0] !== '') {
            selector += '.' + classes.join('.');
        }
    }
    const parent = element.parentElement;
    if (parent && parent.children.length > 1) {
        let nthChild = 1;
        let nthOfType = 1;
        let sibling = element.previousElementSibling;
        while (sibling) {
            nthChild++;
            if (sibling.tagName === element.tagName) {
                nthOfType++;
            }
            sibling = sibling.previousElementSibling;
        }
        selector += `:nth-child(${nthChild})`;
        // Only add nth-of-type if there are other elements with the same tag
        if (nthOfType > 1 || hasNextSiblingWithSameTag(element)) {
            selector += `:nth-of-type(${nthOfType})`;
        }
    }
    return selector;
}
function _generateCssSelector(element) {
    if (!element) {
        return '';
    }
    // Handle case where element has no parent (e.g., detached element)
    if (!element.parentNode) {
        const tagName = element.tagName.toLowerCase();
        if (element.id) {
            return `#${element.id}`;
        }
        let selector = tagName;
        if (element.className && typeof element.className === 'string') {
            const classes = element.className.trim().split(/\s+/);
            if (classes.length > 0 && classes[0] !== '') {
                selector += '.' + classes.join('.');
            }
        }
        return selector;
    }
    // Build the full selector path
    const selectors = [];
    let currentElement = element;
    let depth = 0;
    while (currentElement &&
        currentElement.nodeType === Node.ELEMENT_NODE &&
        depth < MAX_SELECTOR_DEPTH) {
        const selector = getElementSelector(currentElement);
        selectors.unshift(selector);
        // Stop if we found an ID (since IDs should be unique)
        if (currentElement.id) {
            break;
        }
        currentElement = currentElement.parentElement;
        // Stop at document body to avoid going too far up
        if (currentElement && currentElement.tagName.toLowerCase() === 'body') {
            break;
        }
        depth++;
    }
    return selectors.join(' > ');
}
